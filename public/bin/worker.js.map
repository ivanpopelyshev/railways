{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/game/worker","src/core/AABB.js","src/core/Buffer.js","src/core/Builder.js","src/core/FieldObject.js","src/core/GameResources.js","src/core/Generator.js","src/core/Grid.js","src/core/Level.js","src/core/Path.js","src/core/Rails.js","src/core/Segment.js","src/core/Switch.js","src/core/Tracker.js","src/core/TrainWay.js","src/core/WayTracker.js","src/core/index.js","src/core/pixi/Point.js","src/core/pixi/Rectangle.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"worker.js","sourceRoot":"./","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/**\n * Created by Liza on 02.08.2015.\n */\n\nvar Game = require('../core');\nvar Point = Game.Point;\nvar Level = Game.Level;\nvar Rails = Game.Rails;\nvar GameResources = Game.GameResources;\nvar FieldObject = Game.FieldObject;\n\nvar rails;\nvar level, options;\n\nvar genTest = 0, genCallback = null;\n\nvar listener = {\n    removeFront: function() {\n        self.postMessage({\n            method: \"removeFront\"\n        });\n    },\n    addPatch: function(patch) {\n        self.postMessage({\n            method: \"addPatch\",\n            patch: patch.toJson()\n        });\n        if (level && level.patches.length >= genTest && genCallback) {\n            genCallback();\n            genCallback = null;\n        }\n    }\n};\n\nself.addEventListener('message', function(e) {\n    var data = e.data;\n    switch (data.method) {\n        case 'start':\n            options = data.gameRes.options;\n            //options.seed = 5;\n            useAjax = options.hasOwnProperty(\"seed\");\n            if (useAjax) {\n                options.seed = (options.seed%5000);\n                ajaxNum = options.seed;\n            }\n            level = new Level(new GameResources().fromJson(data.gameRes), listener);\n            break;\n        case 'gen':\n            genTest = data.lazyPatches;\n            genCallback = function() {\n                self.postMessage({method: 'done'});\n                resumeGen();\n            };\n            if (useAjax) {\n                tryAjax();\n            } else {\n                level.genSync(data.lazyPatches);\n            }\n            break;\n        case 'close':\n            self.close();\n            break;\n        case 'removeBack':\n            level.removeBack(function() {\n                if (data.cb)\n                    self.postMessage({method: 'done'});\n                resumeGen();\n            });\n            break;\n    }\n}, false);\n\nvar useAjax = false, waitingAjax = false;\nvar ajaxNum = 0;\nfunction tryAjax() {\n    if (waitingAjax) return;\n    if (level.patches.length>=10) return;\n\n    waitingAjax=new XMLHttpRequest();\n    //waitingAjax.overrideMimeType('text\\/plain; charset=x-user-defined');\n    waitingAjax.onreadystatechange=function(){\n        if (waitingAjax.readyState!=4) return;\n        if (waitingAjax.status==200) {\n            //var resp = waitingAjax.response;\n            //var buf = new Game.Buffer(resp.length);\n            //for (var i=0;i<resp.length;i++) buf.data.setUint8(i, resp.charCodeAt(i));\n            //buf.pos = resp.length;\n            //buf.startRead();\n            var buf = new Game.Buffer(waitingAjax.response);\n\n            if (level.patches.length == 1 && ajaxNum == options.seed) {\n                level.removeFront();\n            }\n            while (buf.pos<buf.len) {\n                var patch = new Game.Builder();\n                patch.loadBin(buf, level.gameRes, level.tail(0), false);\n                level.addPatch(patch);\n            }\n            waitingAjax = false;\n            ajaxNum++;\n            tryAjax();\n        } else {\n            useAjax = false;\n            level.removed = true;\n            resumeGen();\n        }\n    };\n\n    waitingAjax.open(\"GET\", \"../railcache/\"+format(Math.floor(ajaxNum/1000)*1000, 6) + \"/\" + format(ajaxNum%1000, 6)+\".dat\",true);\n    waitingAjax.responseType = \"arraybuffer\";\n    waitingAjax.send();\n}\n\nfunction format(id, num) {\n    id=id+\"\";\n    while (id.length<num) id = \"0\"+id;\n    return id;\n};\n\nfunction resumeGen() {\n    if (useAjax )\n        tryAjax();\n    else\n    if (!timeout)\n        timeout = setTimeout(generation, 0);\n}\n\nvar timeout = 0;\n\nfunction generation() {\n    timeout = 0;\n    if (level.doIt2(500)) {\n        resumeGen();\n    }\n}\n","/**\r\n * Created by Liza on 23.07.2015.\r\n */\r\n\r\nvar Rectangle = require('./pixi/Rectangle');\r\n\r\nfunction AABB(bounds) {\r\n    this.bounds = bounds;\r\n}\r\nmodule.exports = AABB;\r\n\r\nAABB.prototype = {\r\n    getBounds: function() {\r\n        return this.bounds;\r\n    },\r\n    intersectRect: function(rect) {\r\n        var bounds = this.bounds;\r\n        return Math.max(rect.x, bounds.x) <= Math.min(rect.x + rect.width, bounds.x + bounds.width) &&\r\n            Math.max(rect.y, bounds.y) <= Math.min(rect.y + rect.height, bounds.y + bounds.height);\r\n    }\r\n}\r\n","/**\r\n * Created by Liza on 04.09.2015.\r\n */\r\n\r\nfunction Buffer(capacity) {\r\n    if (capacity instanceof ArrayBuffer) {\r\n        this.array = capacity;\r\n        this.data = new DataView(this.array);\r\n        this.capacity = this.len = this.array.byteLength;\r\n        this.pos = 0;\r\n        this.readMode = true;//\r\n    } else {\r\n        this.capacity = capacity || (1 << 20);\r\n        this.array = new ArrayBuffer(this.capacity);\r\n        this.data = new DataView(this.array);\r\n        this.startWrite();\r\n    }\r\n}\r\n\r\nmodule.exports = Buffer;\r\n\r\nBuffer.prototype = {\r\n    pos: 0,\r\n    readMode: false,\r\n    writeInt: function (intValue) {\r\n        if (this.readMode) throw \"not write mode\";\r\n        if (this.pos + 4 > this.capacity) throw \"write beyond capacity\";\r\n        this.data.setInt32(this.pos, intValue | 0);\r\n        this.pos += 4;\r\n    },\r\n    writeFloat: function (floatValue) {\r\n        if (this.readMode) throw \"not write mode\";\r\n        if (this.pos + 4 > this.capacity) throw \"write beyond capacity\";\r\n        this.data.setFloat32(this.pos, floatValue);\r\n        this.pos += 4;\r\n    },\r\n    writeString: function (stringValue) {\r\n        if (this.readMode) throw \"not write mode\";\r\n        var len = stringValue.length;\r\n        if (this.pos + 4 * (1 + len) > this.capacity) throw \"write beyond capacity\";\r\n        this.data.setInt32(this.pos, len);\r\n        for (var i = 0; i < len; i++)\r\n            this.data.setInt32(this.pos + 4 * (i + 1), stringValue.charCodeAt(i));\r\n        this.pos += 4 * (1 + len);\r\n    },\r\n    readInt: function () {\r\n        if (!this.readMode) throw \"not read mode\";\r\n        if (this.pos + 4 > this.len) throw \"read beyond end\";\r\n        var intValue = this.data.getInt32(this.pos);\r\n        this.pos += 4;\r\n        return intValue;\r\n    },\r\n    readFloat: function (floatValue) {\r\n        if (!this.readMode) throw \"not read mode\";\r\n        if (this.pos + 4 > this.len) throw \"read beyond end\";\r\n        var floatValue = this.data.getFloat32(this.pos);\r\n        this.pos += 4;\r\n        return floatValue;\r\n    },\r\n    readString: function () {\r\n        if (!this.readMode) throw \"not read mode\";\r\n        if (this.pos + 4 > this.len) throw \"read beyond end\";\r\n        var len = this.data.getInt32(this.pos);\r\n        if (this.pos + 4 * (1 + len) >= this.len) throw \"read beyond end\";\r\n        var s = \"\";\r\n        for (var i = 0; i < len; i++)\r\n            s += String.fromCharCode(this.data.getInt32(this.pos + 4 * (i + 1)));\r\n        this.pos += 4 * (1 + len);\r\n        return s;\r\n    },\r\n    startRead: function () {\r\n        this.readMode = true;\r\n        this.len = this.pos;\r\n        this.pos = 0;\r\n    },\r\n    startWrite: function () {\r\n        this.len = 0;\r\n        this.pos = 0;\r\n        this.readMode = false;\r\n    }\r\n}\r\n","var Point = require('./pixi/Point');\r\nvar Rails = require('./Rails');\r\nvar Path = require('./Path');\r\nvar Segment = require('./Segment');\r\nvar FieldObject = require('./FieldObject');\r\n\r\nfunction Builder() {\r\n    this.objects = [];\r\n    this.start = 0;\r\n    this.paths = [];\r\n    this.finish = [];\r\n    this.prevObjects = [];\r\n    this.prevPath = [];\r\n};\r\n\r\nvar test = [];\r\nBuilder.prototype = {\r\n    length: 0,\r\n    shiftX: 0,\r\n    highway: 0,\r\n    cutHead: function() {\r\n        for (var i=0;i<this.start;i++)\r\n            this.paths[i].cutHead();\r\n    },\r\n    minLength: function() {\r\n        while (test.length>0) test.pop();\r\n        for (var i=0;i<this.paths.length;i++)\r\n            test.push(this.paths[i].length)\r\n        test.sort();\r\n        var res = 0;\r\n        for (var i=0;i<test.length;i++)\r\n            res += (test.length-i)*test[i];\r\n        res += this.gameRes.options.endStationCoeff * this.objects.length;\r\n//        var res = this.finish[0].tail().pos;\r\n//        for (var i=1;i<this.finish.length;i++) {\r\n//            res = Math.min(res, this.finish[i].tail().pos);\r\n//        }\r\n        return res;\r\n    },\r\n    clear: function() {\r\n        while (this.objects.length>0)\r\n            this.objects.pop();\r\n        while (this.paths.length>this.start)\r\n            this.paths.pop();\r\n        while (this.finish.length>0)\r\n            this.finish.pop();\r\n        for (var i=0;i<this.paths.length;i++) {\r\n            this.paths[i].clear();\r\n            this.finish.push(this.paths[i]);\r\n        }\r\n        this.length = 0;\r\n        for (var i=0;i<this.start.length; i++)\r\n            this.length += this.start[i].length;\r\n    },\r\n    addToGrid: function (grid) {\r\n        var addie = grid.addObject.bind(grid);\r\n        for (var i=0;i<this.paths.length;i++) {\r\n            var path = this.paths[i];\r\n            var seg = path.segments;\r\n            for (var j=0;j<seg.length; j++)\r\n                addie(seg[j]);\r\n        }\r\n        this.objects.forEach(addie);\r\n        this.prevObjects.forEach(addie);\r\n        this.prevPath.forEach(addie);\r\n    },\r\n    init1: function(gameRes, path, station) {\r\n        this.rails = path.rails;\r\n        this.gameRes = gameRes;\r\n        this.paths = [path];\r\n        this.start = 1;\r\n        this.finish = this.paths.slice(0);\r\n        if (station)\r\n            this.objects.push(this.createStation(path.head.startPosition, path.head.startAngle));\r\n        this.length = path.length;\r\n    },\r\n    init2: function(prevBuilder, rect) {\r\n        this.rails = prevBuilder.rails;\r\n        this.gameRes = prevBuilder.gameRes;\r\n        var self = this;\r\n        prevBuilder.prevObjects.forEach(function(obj) {\r\n            if (obj.intersectRect(rect)) self.prevObjects.push(obj);\r\n        });\r\n        prevBuilder.objects.forEach(function(obj) {\r\n            if (obj.intersectRect(rect)) self.prevObjects.push(obj);\r\n        });\r\n        prevBuilder.prevPath.forEach(function(obj) {\r\n            if (obj.intersectRect(rect)) self.prevPath.push(obj);\r\n        });\r\n        prevBuilder.paths.forEach(function(path) {\r\n            path.segments.forEach(function(obj) {\r\n                if (obj.intersectRect(rect)) self.prevPath.push(obj);// self.prevPath.push(new Segment().copy(obj));\r\n            });\r\n        });\r\n        this.start = prevBuilder.finish.length;\r\n        for (var i=0; i<this.start;i++) {\r\n            this.paths.push(new Path().init2(prevBuilder.finish[i]));\r\n        }\r\n        this.start = this.paths.length;\r\n        this.finish = this.paths.slice(0);\r\n        //temporary for test\r\n        this.length = 0;\r\n        for (var i=0;i<this.start; i++) {\r\n            this.paths[i].pos = 0;\r\n        }\r\n    },\r\n    createStation: function(position, angle) {\r\n        var rails = this.rails;\r\n/*        if (angle == rails.grad * 7/8) {\r\n            return new FieldObject(this.models[\"new_station2\"], new Point(position.x - 17, position.y - 62));\r\n        } else  if (angle == rails.grad * 5/8) {\r\n            return new FieldObject(this.models[\"new_station1\"], new Point(position.x - 46, position.y - 215));\r\n        } else if (angle == rails.grad * 6/8) {\r\n            return new FieldObject(this.models[\"new_station3\"], new Point(position.x - 00, position.y - 150));\r\n        } else return null;*/\r\n        var st = this.gameRes.stations;\r\n        while (test.length>0) test.pop();\r\n        for (var i=0;i<st.length;i++) {\r\n            var s = st[i];\r\n            if (angle == rails.grad * s.angle/8) {\r\n                test.push(s);\r\n            }\r\n        }\r\n        if (test.length==0) return null;\r\n        var s = test[Math.random() * test.length | 0];\r\n        var objs = { list: [], railLen: s.railLen, bonusRail: s.bonusRail } ;\r\n        for (var j=0;j< s.list.length;j++) {\r\n            var m = s.list[j];\r\n            var obj = new FieldObject(this.gameRes.models[m.model], new Point(position.x + m.x, position.y + m.y));\r\n            obj.name = m.name || obj.name;\r\n            objs.list.push(obj);\r\n        }\r\n        return objs;\r\n    },\r\n    clone: function() {\r\n        var b = new Builder();\r\n        b.rails = this.rails;\r\n        b.gameRes = this.gameRes;\r\n        b.start = this.start;\r\n        b.highway = this.highway;\r\n        var railClones = {};\r\n        for (var i=0;i<this.paths.length;i++) {\r\n            var path = this.paths[i].clone();\r\n            var seg = path.segments;\r\n            b.paths.push(path);\r\n            if (i>=this.start) {\r\n                path.head = railClones[path.head.id] || path.head;\r\n            }\r\n            for (var j=0;j<seg.length;j++) {\r\n                railClones[seg[j].id] = seg[j];\r\n            }\r\n        }\r\n        for (var i=0; i<this.finish.length;i++) {\r\n            var k = this.paths.indexOf(this.finish[i]);\r\n            b.finish.push(b.paths[k]);\r\n        }\r\n        for (var i=0;i<b.paths.length;i++) {\r\n            var path = b.paths[i];\r\n            for (var j=0;j<path.waysIn.length; j++) {\r\n                var w = path.waysIn[j];\r\n                w.pathFrom = b.paths[this.paths.indexOf(w.pathFrom)];\r\n                w.railFrom = railClones[w.railFrom.id] || w.railFrom;\r\n                w.railTo = railClones[w.railTo.id] || w.railTo;\r\n            }\r\n            for (var j=0;j<path.waysOut.length; j++) {\r\n                var w = path.waysOut[j];\r\n                w.pathTo = b.paths[this.paths.indexOf(w.pathTo)];\r\n                w.railFrom = railClones[w.railFrom.id] || w.railFrom;\r\n                w.railTo = railClones[w.railTo.id] || w.railTo;\r\n            }\r\n            this.paths[i].check();\r\n            path.check();\r\n        }\r\n        b.objects = this.objects.slice(0);\r\n        for (var i=0;i<b.objects.length;i++) {\r\n            var obj = b.objects[i];\r\n            if (obj.rail)\r\n                obj.rail = railClones[obj.rail.id];\r\n        }\r\n        b.length = this.length;\r\n        b.prevObjects = this.prevObjects;\r\n        b.prevPath = this.prevPath;\r\n        return b;\r\n    },\r\n    initLinkedList: function(cut) {\r\n        for (var i = 0; i < this.paths.length; i++) {\r\n            var path = this.paths[i];\r\n            var seg = path.segments;\r\n            if (i<this.start) {\r\n                path.head.pos = path.head.len;\r\n                //recovery. we have a problem in generator.\r\n                //TODO: remove it!\r\n                if (path.segments[0] && path.segments[0] != path.head) {\r\n                    path.head.pos = path.segments[0].pos - path.segments[0].len;\r\n                } else if (path.segments[1]) {\r\n                    path.head.pos = path.segments[1].pos - path.segments[1].len;\r\n                }\r\n            }\r\n            for (var j=1;j<seg.length;j++) {\r\n                var segment = seg[j];\r\n                seg[j-1].next = seg[j];\r\n                seg[j-1].nextPos = 0;\r\n                seg[j].prev = seg[j-1];\r\n                if (!cut)\r\n                    seg[j].pos = seg[j-1].pos + seg[j].len;\r\n            }\r\n            for (var j=0;j<path.waysIn.length;j++) {\r\n                var way = path.waysIn[j];\r\n                var tail = way.pathFrom.tail();\r\n                tail.next = way.railTo;\r\n                tail.nextPos = way.posTo - (way.railTo.pos - way.railTo.len - path.head.pos);\r\n            }\r\n        }\r\n        for (var i = this.paths.length-1; i >= 0; i--) {\r\n            var path = this.paths[i];\r\n            var seg = path.segments;\r\n            if (!path.isStart()) {\r\n                if (this.paths.indexOf(path.head.path) < 0) {\r\n                    path.head.next = seg[0];\r\n                    path.head.nextPos = 0;\r\n                }\r\n                seg[0].prev = path.head;\r\n            }\r\n        }\r\n    },\r\n    randomizeWays: function() {\r\n        for (var i = 0; i < this.paths.length; i++) {\r\n            var path = this.paths[i];\r\n            var seg = path.segments;\r\n            if (path.waysOut.length>0) {\r\n                var way = path.waysOut[(path.waysOut.length + 1) * Math.random() | 0];\r\n                if (way) {\r\n                    var tail = way.railFrom;\r\n                    tail.next = way.railTo;\r\n                    tail.nextPos = way.posTo - (way.railTo.pos - way.railTo.len - way.pathTo.head.pos);\r\n                }\r\n            }\r\n        }\r\n    },\r\n    canRemove: function(path) {\r\n        return !path.canPop() && this.paths.indexOf(path)>=this.start;\r\n    },\r\n    addPath: function(path) {\r\n        this.paths.push(path);\r\n        if (!path.mergesTo)\r\n            this.finish.push(path);\r\n    },\r\n    removePath: function(path) {\r\n        this.paths.splice(this.paths.indexOf(path), 1);\r\n        var k = this.finish.indexOf(path);\r\n        if (k>=0)\r\n            this.finish.splice(k, 1);\r\n        return k>=0;\r\n    },\r\n    toJson: function() {\r\n        return {\r\n            shiftX : this.shiftX,\r\n            start: this.start,\r\n            highway: this.highway,\r\n            objects: this.objects.map(toJson),\r\n            paths: this.paths.map(toJson),\r\n            finish: this.finish.map(toJsonId)\r\n        };\r\n    },\r\n    fromJson: function(json, gameRes, previousPatch) {\r\n        var segmentById = {};\r\n        var pathById = {};\r\n        var rails = this.rails = gameRes.rails;\r\n        this.gameRes = gameRes;\r\n        this.start = json.start;\r\n        this.shiftX = json.shiftX;\r\n        this.highway = json.highway;\r\n        this.paths = json.paths.map(function(obj) {\r\n            var p = new Path().fromJson(obj, rails);\r\n            pathById[p.id]=p;\r\n            p.segments.forEach(function(obj) {\r\n                segmentById[obj.id] = obj\r\n            });\r\n            return p;\r\n        });\r\n        this.objects = json.objects.map(function(obj) {\r\n            var f = new FieldObject(gameRes.models[obj.model], obj.position, obj.scale, obj.name);\r\n            if (obj.railId) {\r\n                f.rail = segmentById[obj.railId];\r\n                f.rail.mapObj = obj;\r\n            }\r\n            return f;\r\n        });\r\n        this.finish = json.finish.map(function(id) { return pathById[id] });\r\n        if (previousPatch)\r\n            previousPatch.finish.forEach(function(obj) { segmentById[obj.tail().id] = obj.tail(); });\r\n        this.paths.forEach(function(obj) { obj.fromJsonStep2(segmentById, pathById) });\r\n        this.initLinkedList();\r\n        return this;\r\n    },\r\n    saveBin: function(buffer) {\r\n        var self = this;\r\n        function save(x) {\r\n            x.saveBin(buffer, self.gameRes.models);\r\n        }\r\n        buffer.writeFloat(this.shiftX);\r\n        buffer.writeInt(this.start);\r\n        buffer.writeFloat(this.highway);\r\n        buffer.writeInt(this.paths.length);\r\n        this.paths.forEach(save);\r\n        buffer.writeInt(this.objects.length);\r\n        this.objects.forEach(save);\r\n        buffer.writeInt(this.finish.length);\r\n        this.finish.forEach(function(x) {buffer.writeInt(x.id);});\r\n    },\r\n    loadBin: function(buffer, gameRes, previousPatch) {\r\n        var segmentById = {};\r\n        var pathById = {};\r\n        var rails = this.rails = gameRes.rails;\r\n        this.gameRes = gameRes;\r\n        this.shiftX = buffer.readFloat();\r\n        this.start = buffer.readInt();\r\n        this.highway = buffer.readFloat();\r\n        for (var i=buffer.readInt();i>0;i--) {\r\n            var path = new Path();\r\n            path.rails = rails;\r\n            path.loadBin(buffer);\r\n            pathById[path.id] = path;\r\n            path.segments.forEach(function(obj) {\r\n                segmentById[obj.id] = obj\r\n            });\r\n            this.paths.push(path);\r\n        }\r\n        for (var i=buffer.readInt();i>0;i--) {\r\n            var obj = FieldObject.prototype.createFromBin(buffer, this.gameRes.models);\r\n            if (obj.railId) {\r\n                obj.rail = segmentById[obj.railId];\r\n                obj.rail.mapObj = obj;\r\n            }\r\n            this.objects.push(obj);\r\n        }\r\n        for (var i=buffer.readInt();i>0;i--) {\r\n            var id = buffer.readInt();\r\n            this.finish.push(pathById[id]);\r\n        }\r\n        var cut = !previousPatch;\r\n        if (previousPatch) {\r\n            previousPatch.finish.forEach(function (obj) {\r\n                segmentById[obj.tail().id] = obj.tail();\r\n            });\r\n            for (var i=0;i<this.start;i++) {\r\n                var path = this.paths[i];\r\n                if (path.head == path.segments[0].id)\r\n                    path.segments.shift();\r\n            }\r\n        }\r\n        if (cut) {\r\n            for (var i=0;i<this.start;i++) {\r\n                var path = this.paths[i];\r\n                path.head = path.segments[0].id;\r\n            }\r\n        }\r\n        this.paths.forEach(function(obj) { obj.fromJsonStep2(segmentById, pathById) });\r\n        this.initLinkedList(cut);\r\n        this.superFix();\r\n        return this;\r\n    },\r\n    superFix: function() {\r\n        var paths = this.paths;\r\n        for (var i=0;i<paths.length;i++) {\r\n            var path = paths[i];\r\n            var segments = path.segments;\r\n            for (var j=0;j<segments.length;j++) {\r\n                if (j==0 && path.isStart()) continue;\r\n                var seg = segments[j];\r\n                var sx = seg.prev.endPosition.x - seg.startPosition.x;\r\n                seg.positions = null;\r\n                seg.startPosition.x += sx;\r\n                seg.centerPosition.x += sx;\r\n                seg.endPosition.x += sx;\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nvar toJson = function(obj) {return obj.toJson(); };\r\nvar toJsonId = function(obj) {return obj.id; };\r\n\r\nmodule.exports = Builder;\r\n","/**\r\n * Created by Liza on 23.07.2015.\r\n */\r\n\r\nvar Point = require('./pixi/Point');\r\nvar Rectangle = require('./pixi/Rectangle');\r\n\r\nfunction FieldObject(model, fixtures, scale, name) {\r\n    this.positions = [];\r\n    if (model.name) {\r\n        this.name = name || model.name;\r\n        this.translate(model, fixtures, scale);\r\n    } else\r\n    if (fixtures) {\r\n        this.proto = this;\r\n        this.name = model;\r\n        this.fixtures = fixtures;\r\n        this.filter = 0;\r\n        this.density = fixtures[0].density;\r\n        for (var i=0;i<fixtures.length;i++) {\r\n            var row = [];\r\n            this.filter |= fixtures[i].filter.categoryBits;\r\n            this.positions.push(row);\r\n            for (var j=0;j<fixtures[i].shape.length;j+=2) {\r\n                var point = new Point(fixtures[i].shape[j], fixtures[i].shape[j+1]);\r\n                row.push(point);\r\n            }\r\n        }\r\n        var b = this.getBounds();\r\n        this.anchor = new Point(b.x + b.width/2, b.y + b.height/2);\r\n    }\r\n}\r\n\r\nmodule.exports = FieldObject;\r\n\r\nFieldObject.prototype = {\r\n    //convex: true,\r\n    translate: function(model, position, scale) {\r\n        this.proto = model;\r\n        this.position = position;\r\n        this.scale = scale = scale || new Point(1, 1);\r\n        this.positions = [];\r\n        for (var i = 0; i < model.positions.length; i++) {\r\n            var row = [];\r\n            this.positions.push(row);\r\n            for (var j = 0; j < model.positions[i].length; j++) {\r\n                var point = new Point(model.positions[i][j].x*scale.x + position.x, model.positions[i][j].y*scale.y + position.y);\r\n                row.push(point);\r\n            }\r\n        }\r\n    },\r\n    getBounds: function() {\r\n        if (!this.bounds) {\r\n            var p = this.positions[0][0];\r\n            var minX = p.x, maxX = p.x, minY = p.y, maxY = p.y;\r\n            for (var i = 0; i < this.positions.length; i++)\r\n                for (var j = 0; j < this.positions[i].length; j++) {\r\n                    p = this.positions[i][j];\r\n                    minX = Math.min(minX, p.x);\r\n                    maxX = Math.max(maxX, p.x);\r\n                    minY = Math.min(minY, p.y);\r\n                    maxY = Math.max(maxY, p.y);\r\n                }\r\n            this.bounds = new Rectangle(minX, minY, maxX - minX, maxY - minY);\r\n        }\r\n        return this.bounds;\r\n    },\r\n    intersectRect: function(rect) {\r\n        for (var i = 0; i < this.positions.length; i++) {\r\n            var n = this.positions[i].length;\r\n            var minY= +1e+9, maxY =-1e+9;\r\n            var found = 0;\r\n            for (var j = 0; j < n; j++) {\r\n                var p1 = this.positions[i][j];\r\n                var p2 = this.positions[i][(j+1)%n];\r\n                if (p1.x>p2.x) {\r\n                    var t = p1;p1=p2;p2=t;\r\n                }\r\n                if (rect.x <= p1.x && rect.x + rect.width >= p2.x) {\r\n                    minY = Math.min(minY, Math.min(p1.y, p2.y));\r\n                    maxY = Math.max(maxY, Math.max(p1.y, p2.y));\r\n                } else\r\n                {\r\n                    if (rect.x + rect.width >= p1.x && rect.x + rect.width <= p2.x) {\r\n                        var y = (rect.x + rect.width - p1.x) / (p2.x - p1.x) * (p2.y - p1.y) + p1.y;\r\n                        minY = Math.min(minY, y);\r\n                        maxY = Math.max(maxY, y);\r\n                    }\r\n                    if (rect.x <= p2.x && rect.x >= p1.x) {\r\n                        var y = (rect.x - p1.x) / (p2.x - p1.x) * (p2.y - p1.y) + p1.y;\r\n                        minY = Math.min(minY, y);\r\n                        maxY = Math.max(maxY, y);\r\n                    }\r\n                }\r\n            }\r\n            if (Math.max(minY, rect.y) <= Math.min(maxY, rect.y + rect.height)) return true;\r\n        }\r\n        return false;\r\n    },\r\n    liesInRect: function(rect) {\r\n        for (var i = 0; i < this.positions.length; i++) {\r\n            var n = this.positions[i].length;\r\n            for (var j = 0; j < n; j++) {\r\n                var p1 = this.positions[i][j];\r\n                if (!rect.contains(p1.x, p1.y))\r\n                    return false;\r\n            }\r\n        }\r\n        return true;\r\n    },\r\n    toJson: function() {\r\n        if (this.proto != null) {\r\n            return {\r\n                name: this.name,\r\n                model: this.proto.name,\r\n                position: this.position,\r\n                scale: this.scale,\r\n                railId: this.rail?this.rail.id:0\r\n            }\r\n        } else {\r\n            return {\r\n                name: this.name,\r\n                fixtures: this.fixtures\r\n            }\r\n        }\r\n    },\r\n    saveBin: function (buffer, models) {\r\n        var nameId = this.getKeyNumber(models, this.name);\r\n        buffer.writeInt(nameId);\r\n        if (nameId == -1) {\r\n            buffer.writeString(this.name);\r\n        }\r\n        var modelId = this.getKeyNumber(models, this.proto.name);\r\n        buffer.writeInt(modelId);\r\n        buffer.writeFloat(this.position.x);\r\n        buffer.writeFloat(this.position.y);\r\n        buffer.writeFloat(this.scale.x);\r\n        buffer.writeFloat(this.scale.y);\r\n        buffer.writeInt(this.rail?this.rail.id:0);\r\n    },\r\n    getKeyNumber: function(models, name) {\r\n        var i = 0;\r\n        for (var key in models) if (models.hasOwnProperty(key)) {\r\n            if (key == this.name) return i;\r\n            i++;\r\n        }\r\n        return -1;\r\n    },\r\n    getKey: function(models, keyNumber) {\r\n        var i = 0;\r\n        for (var key in models) if (models.hasOwnProperty(key)) {\r\n            if (i == keyNumber) return key;\r\n            i++;\r\n        }\r\n        return key;\r\n    },\r\n    createFromBin: function(buffer, models) {\r\n        var nameId = buffer.readInt();\r\n        var name = nameId<0?buffer.readString():this.getKey(models, nameId);\r\n        var modelId = buffer.readInt();\r\n        var model = models[this.getKey(models, modelId)];\r\n        //TODO: remove this hack\r\n        if (name == \"station1\") model = models[\"station\"];\r\n\r\n        var position = new Point(buffer.readFloat(), buffer.readFloat());\r\n        var scale = new Point(buffer.readFloat(), buffer.readFloat());\r\n        var s = new FieldObject(model, position, scale, name);\r\n        s.railId = buffer.readInt();\r\n        return s;\r\n    }\r\n}\r\n","/**\n * Created by Liza on 11.08.2015.\n */\n\n\nvar Rails = require('./Rails');\nvar Point = require('./pixi/Point');\nvar FieldObject = require('./FieldObject');\n\nfunction GameResources(options, shapes, atlas, clusters, stations) {\n    this.options = options;\n    this.shapes = shapes;\n    this.atlas = atlas;\n    this.clusters = clusters;\n    this.stations = stations;\n}\n\nmodule.exports = GameResources;\n\nGameResources.prototype = {\n    initModels: function () {\n        if (this.models) return;\n        var options = this.options;\n        var atlas = this.atlas.frames;\n        var models = this.models = {};\n        var shapes = this.shapes;\n        for (var key in shapes) if (shapes.hasOwnProperty(key)) {\n            models[key] = new FieldObject(key, shapes[key]);\n            models[key].model = key;\n            if (atlas.hasOwnProperty(key + \"b\")) {\n                models[key + \"b\"] = models[key];\n            }\n        }\n        var rails = this.rails = new Rails(72, new Point(options.railsSize, options.railsSize * 2 / 3), 64, 2);\n        if (!this.clusters) {\n            var clusters = this.clusters = [];\n            if (this.options.clusters != 1) {\n                for (var key in shapes) if (shapes.hasOwnProperty(key)) {\n                    if (key.indexOf(\"station\") < 0 && key.indexOf(\"bridge\") < 0 && key.indexOf(\"perehod\") < 0 && key.indexOf(\"platform\") < 0) {\n                        var obj = {\n                            main: [key]\n                        }\n                        if (atlas.hasOwnProperty(key + \"b\")) {\n                            obj.main.push(key + \"b\");\n                        }\n                        clusters.push(obj);\n                    }\n                }\n            } else {\n                var trees = [\"bush1\", \"pine1\", \"tree1\", \"tree2\"];\n\n                var rocks = [\"bigrock1\", \"bigrock2\", \"smallcrag1\", \"smallcrag2\", \"smallrock1\", \"smallrock2\", \"smallrock3\"];\n                var big = [[\"crag1\", \"crag2\", \"pond1\"]];\n\n                var lst = [];\n                big.forEach(function (bigStuff) {\n                    var cluster = {\n                        tries: 100, once: true,\n                        main: bigStuff,\n                        secondary: [\n                            {radMin: 10, radMax: 100, count: 5, tries: 100, list: lst},\n                            {radMin: 100, radMax: 200, count: 5, tries: 100, list: lst}\n                        ]\n                    };\n                    trees.forEach(function (t) {\n                        lst.push(t);\n                        lst.push(t + \"b\");\n                        lst.push(t);\n                        lst.push(t + \"b\");\n                    });\n                    rocks.forEach(function (t) {\n                        lst.push(t);\n                    });\n                    clusters.push(cluster);\n                });\n                for (var i = 0; i < 3; i++) {\n                    var tr1 = [trees[i], trees[i] + \"b\"];\n                    if (i == 2) {\n                        tr1.push(trees[3]);\n                        tr1.push(trees[3] + \"b\");\n                    }\n                    var tr2 = [];\n                    tr1.forEach(function (t) {\n                        tr2.push(t)\n                    })\n                    tr1.forEach(function (t) {\n                        tr2.push(t)\n                    })\n                    tr1.forEach(function (t) {\n                        tr2.push(t)\n                    })\n                    tr1.forEach(function (t) {\n                        tr2.push(t)\n                    })\n                    rocks.forEach(function (t) {\n                        tr2.push(t)\n                    })\n                    cluster = {\n                        tries: 20,\n                        main: trees, neibRadius: 100,\n                        secondary: [\n                            {radMin: 10, radMax: 100, count: 5, tries: 100, list: tr1},\n                            {radMin: 100, radMax: 200, count: 5, tries: 100, list: tr2}\n                        ]\n                    };\n                    clusters.push(cluster);\n                }\n            }\n        }\n        if (!this.rivers) {\n            this.rivers = {\n                water: [{ p: 10, list: [{ model: \"river2\", shiftX: 150 }] },\n                    { p:1, list: [ {model: \"riverbig1\", shiftX: options.width - 714},\n                      { model: \"riverbig2\", shiftX: 714 }, {model: \"riverbig3\", shiftY: options.height-429, shiftX: 1200}]}],\n                bridges: [\n                    {\n                        \"angle\": 5,\n                        \"len\": 100,\n                        \"padding\": 15,\n                        \"base\": \"bridgeNE_base\",\n                        \"top\": \"bridgeNE_top\"\n                    },\n                    {\n                        \"angle\": 7,\n                        \"len\": 100,\n                        \"padding\": 15,\n                        \"base\": \"bridgeSE_base\",\n                        \"top\": \"bridgeSE_top\"\n                    },\n                    {\n                        \"angle\": 6,\n                        \"len\": 100,\n                        \"padding\": 15,\n                        \"base\": \"bridgeE_base\",\n                        \"top\": \"bridgeE_top\"\n                    }\n                ]\n            }\n        }\n        if (!this.stations) {\n            var stations = this.stations = [];\n            stations.push({\n                \"angle\": 6,\n                \"bonusRail\": 200,\n                \"list\": [\n                    {\"x\": 0, \"y\": -210, \"model\": \"station\", \"name\": \"station1\"},\n                    {\"x\": 18, \"y\": 20, \"model\": \"platform\", \"name\": \"platform\"},\n                    //{ \"x\": 0, \"y\": -100, \"model\": \"station\"},\n                    {\"x\": 285, \"y\": -110, \"model\": \"perehod_base\"},\n                    {\"x\": 285, \"y\": -110, \"model\": \"perehod_top\"}\n                ]\n            })\n            stations.push({\n                \"angle\": 6,\n                \"bonusRail\": 150,\n                \"list\": [\n                    {\"x\": 18, \"y\": -50, \"model\": \"platform\", \"name\": \"station2\"},\n                    {\"x\": 18, \"y\": 20, \"model\": \"platform\", \"name\": \"platform\"},\n                    {\"x\": 285, \"y\": -110, \"model\": \"perehod_base\"},\n                    {\"x\": 285, \"y\": -110, \"model\": \"perehod_top\"}\n                ]\n            })\n        }\n        if (!this.obstacles) {\n            this.obstacles = [\n//                { name: \"pointer_coin\", duration: 0.2},\n//                { name: \"evacuator\", duration: 1},\n//                { name: \"lights\", duration: 1},\n                {\n                    prob: 1, name: \"phones1\", duration: 0.5, vel: 10,\n                    icons: [\"phones1\", \"phones2\"], iconAnimSpeed: 1000,\n                    useHorn: 400,\n                    pointerIcon: \"pointer3\",\n                    humanModels: [\"man\", \"man_color1\", \"man_color2\", \"man_color3\"]\n                },\n                {\n                    prob: 0.5, name: \"runner\", duration: 0.5, vel: 3.5, walkVel: 30, state: 3,\n                    icons: [\"runner\"]\n                },\n                {\n                    name: \"highway\", duration: 0.5, betweenMin: 100, betweenMax: 150, minDistance: 50,\n                    vel: 120,\n                    icons: [\"lights\"],\n                    carModels: [\"car1\", \"car2\", \"car3\", \"car4\"]\n                },\n                {\n                    prob: 1, name: \"kids\", duration: 0.5, radius: 50, vel: 40, humanCount: 2,\n                    icons: [\"children\"],\n                    humanModels: [\"child\", \"child2\"]\n                },\n                {\n                    prob: 1, name: \"junk\", duration: 0.5,\n                    icons: [\"trash\"]\n                },\n                //several variants of stations\n                {\n                    name: \"lights1\", bindObj: \"station1\", duration: 0.5, humanCount: 10, railPos: 100,\n                    vel: 80,\n                    walkingCount: 5,\n                    icons: [\"lights\"],\n                    platforms: [\n                        {x: 50, y: -30, w: 280, h: 7},\n                        {x: 40, y: 35, w: 320, h: 15}\n                    ],\n                    ways: [\n                        [{x: 340, y: -25}, {x: 340, y: 35}],\n                        [{x: 345, y: 35}, {x: 345, y: -25}],\n                        [{x: 370, y: -30}, {x: 462, y: -30, z: 40}, {x: 476, y: -30, z: 40},\n                            {x: 476, y: 35, z: 40}, {x: 462, y: 35, z: 40}, {x: 370, y: 35}],\n                        [{x: 370, y: 40}, {x: 462, y: 35, z: 40}, {x: 476, y: 35, z: 40},\n                            {x: 476, y: -30, z: 40}, {x: 476, y: -30, z: 40}, {x: 370, y: -30}]\n                    ],\n                    humanModels: [\"man\", \"man_color1\", \"man_color2\", \"man_color3\"]\n                },\n                {\n                    name: \"lights2\", bindObj: \"station2\", duration: 0.5, humanCount: 10, railPos: 100,\n                    vel: 80,\n                    walkingCount: 5,\n                    icons: [\"lights\"],\n                    platforms: [\n                        {x: 50, y: -30, w: 280, h: 7},\n                        {x: 40, y: 35, w: 320, h: 15}\n                    ],\n                    ways: [\n                        [{x: 340, y: -25}, {x: 340, y: 35}],\n                        [{x: 345, y: 35}, {x: 345, y: -25}],\n                        [{x: 370, y: 40}, {x: 462, y: 35, z: 40}, {x: 476, y: 35, z: 40},\n                            {x: 476, y: -30, z: 40}, {x: 476, y: -30, z: 40}, {x: 370, y: -30}]\n                    ],\n                    humanModels: [\"man\", \"man_color1\", \"man_color2\", \"man_color3\"]\n                },\n                {\n                    prob: 100, name: \"delorean\", duration: 2.5, vel: 120,\n                    exactPlace: 20430, maxTimes: 1, showScore: 2015,\n                    icons: [\"evacuator\"],\n                    carModels: [\"delorean\"]\n                }\n            ]\n        }\n    },\n    toJson: function () {\n        return {\n            options: this.options,\n            shapes: this.shapes,\n            atlas: this.atlas,\n            clusters: this.clusters,\n            stations: this.stations,\n            rivers: this.rivers,\n            obstacles: this.obstacles\n        }\n    },\n    fromJson: function (json) {\n        this.options = json.options;\n        this.shapes = json.shapes;\n        this.atlas = json.atlas;\n        this.clusters = json.clusters;\n        this.stations = json.stations;\n        this.rivers = json.rivers;\n        this.obstacles = json.obstacles;\n        this.initModels();\n        return this;\n    }\n}\n","/**\n * Created by Liza on 23.07.2015.\n */\n\nvar Point = require('./pixi/Point');\nvar Rectangle = require('./pixi/Rectangle');\nvar Rails = require('./Rails');\nvar Path = require('./Path');\nvar Builder = require('./Builder');\n//var seedrandom = require('seedrandom');\nvar Grid = require('./Grid');\nvar Switch = require('./Switch');\nvar FieldObject = require('./FieldObject');\nvar AABB = require('./AABB');\n\nmodule.exports = function Generator(prevBuilder, options) {\n    options = options || {};\n\n    var self = this;\n    var rails = prevBuilder.rails;\n\n    var rect = options.rect || new Rectangle(0, 0, 1200, 720);\n    var rect2 = options.rect2 || new Rectangle(0, 0, 1200, 720);\n    var rand = {\n        quick: function () {\n            return Math.random();\n        }\n    }\n//    if (prevBuilder.paths.length == 1 && prevBuilder.paths[0].segments.length==1)\n//        options.seed = Math.random() * 100000 | 0;\n//    else options.seed = Math.random() * 100000 | 0;\n    //var rand = new seedrandom(options.seed);\n    //if (prevBuilder.paths.length == 1 && prevBuilder.paths[0].segments.length==1)\n    //    console.log(\"seed=\"+options.seed);\n\n    var endLen = options.endLen || 50;\n//    var minShiftX = options.minShiftX || 100;\n//    var maxShiftX = options.maxShiftX || 150;\n    var shiftX = options.shiftX || Math.ceil(rails.scale.x * 25);\n    var shiftY = options.shiftY || Math.ceil(rails.scale.x * 50);\n\n    var recTries = options.recTries || 1000;\n    var innerTries = options.innerTries || 2;\n    var endStation = options.endStation || 0.5;\n    var maxWays = options.maxWays || 3;\n    var minWays = options.minWays || 2;\n\n    var minLen = options.minLen || 0;\n\n    var objectsCount = options.objectsCount || ( options.clusters ? 10 : 200);\n    var riverProb = options.riverProb || 0.4;\n    var hasRiver = Math.random() < riverProb;\n\n    var highwayWidth, highwayProb = 0;\n    if (prevBuilder.gameRes.atlas.frames['road']) {\n        highwayWidth = options.highwayWidth || prevBuilder.gameRes.atlas.frames['road'].frame.w;\n        highwayProb = options.highwayProb || 0.3;\n    }\n\n    //this is for intersections:\n    var grid;\n    if (options.intersections) {\n        grid = new Grid({\n            rect: rect,\n            tileW: Math.ceil(rails.scale.x * 5),\n            tileH: Math.ceil(rails.scale.x * 3),\n            border: 2\n        });\n    } else\n        grid = new Grid({rect: rect, tileW: Math.ceil(rails.scale.x * 7.5), tileH: Math.ceil(rails.scale.x * 5)});\n\n    var testSegment;\n\n    var endRects = [];\n\n    var tryObjectsPrevRail;\n    function tryObjects(objs, prevRail) {\n        tryObjectsPrevRail = prevRail;\n        for (var i = 0; i < objs.length; i++) {\n            if (!addObject(objs[i], false, true)) {\n                tryObjectsPrevRail = null;\n                return false;\n            }\n        }\n        tryObjectsPrevRail = null;\n        return true;\n    }\n\n    function isEnd(path) {\n        var p = path.tail().endPosition;\n        var endAngle = path.tail().endAngle;\n        var endLen_ = endLen;\n        var bonusLen = 0;\n\n        var rail1 = testSegment = rails.createStraight(p, endAngle, endLen, testSegment);\n        var p2 = rail1.endPosition;\n        var sx = p2.x - rect.x - rect.width;\n\n        if ((sx >= 0 && sx <= shiftX) && (p2.y - rect2.y <= rect2.height - shiftY && endAngle == rails.grad * 7 / 8 ||\n            p2.y - rect2.y >= shiftY && endAngle == rails.grad * 5 / 8 || endAngle == rails.grad * 6 / 8)) {\n            if (build.highway) {\n                //TODO: two more directions\n                if (endAngle == rails.grad * 6 / 8) {\n                    var tail = path.addStraight(endLen_ + highwayWidth / rails.scale.x);\n                    tail.highwayPos = (rect.x + rect.width - testSegment.startPosition.x) / rails.scale.x;\n                    if (addRail(tail, false, true)) {\n                        //may be add object here\n                        path.isEnd = [];\n                        return true;\n                    }\n                    path.pop();\n                }\n            } else {\n                var objs = null;\n                if (canPlaceAfter && rand.quick() < endStation) {\n                    objs = build.createStation(p, endAngle);\n                    if (objs && objs.railLen) endLen_ = objs.railLen;\n                    if (objs && objs.bonusRail) endLen_ = objs.bonusRail;\n                    //if (obj == null) {\n                    //    return false;\n                    //}\n                }\n                var endRect = new AABB(new Rectangle(sx, p2.y - rails.radius / 2, rails.radius, rails.radius));\n                for (var i = 0; i < endRects.length; i++) {\n                    if (endRects[i].intersectRect(endRect)) {\n                        return false;\n                    }\n                }\n                if (!objs || tryObjects(objs.list, path.tail())) {\n                    var tail = path.addStraight(endLen_);\n                    if (addRail(tail, objs && objs.bonusRail, true)) {\n                        endRects.push(endRect);\n                        path.isEnd = [endRect];\n                        if (objs) {//\n                            tail.mapObj = objs.list[0];\n                            objs.list[0].rail = tail;\n                            for (var i = 0; i < objs.list.length; i++) {\n                                var obj = objs.list[i];\n                                path.isEnd.push(obj);\n                                addObject(obj, true, false);\n                            }\n                        }\n                        return true;\n                    }\n                    path.pop();\n                }\n            }\n        }\n        return false;\n    }\n\n    var sid = 0;\n    var temp = new Point();\n    var pos = [];\n\n    var interRail = null;\n\n    function addRail(rail, ignoreProblems, canGoRight, riverPadding) {\n        interRail = null;\n        var rail2 = rail.prev;\n        if (!(rail.endPosition.x - rails.w >= rect2.x &&\n            (rail.endPosition.x + rails.w <= rect2.x + rect2.width || canGoRight) &&\n            rail.endPosition.y - rails.h >= rect2.y &&\n            rail.endPosition.y + rails.h <= rect2.y + rect2.height)) {\n            if (!ignoreProblems)\n                return false;\n        }\n        rail.cells = [];\n        rail.sid = ++sid;\n        while (pos.length > 0) pos.pop();\n        rail.fillPositions(pos, 3);\n        for (var i = 0; i < pos.length; i += 2) {\n            if (canGoRight && (pos[i] >= rect.x + rect.width)) continue;\n            var cell = grid.cellAt(pos[i], pos[i + 1]);\n            var pad = rail.len * i / (pos.length - 1);\n            if (cell == null) {\n                if (!ignoreProblems) return false;\n            } else if (cell.sid != sid) {\n                if (cell.border < 0) {\n                    if (!ignoreProblems) return false;\n                    continue;\n                }\n                if (!ignoreProblems && cell.contents.length > 0) {\n                    if (!rail2 || rail2.cells.indexOf(cell) < 0) {\n                        for (var j = 0; j < cell.contents.length; j++) {\n                            var obj = cell.contents[j];\n                            //oops, we have siblings!\n                            if (obj.prev && obj.prev == rail2 &&\n                                obj.curve != rail.curve) continue;\n                            if (riverPadding && obj.river && pad >= riverPadding && pad <= rail.len - riverPadding) continue;\n                            interRail = cell.contents[0];\n                            return false;\n                        }\n                    }\n                }\n                cell.sid = sid;\n                rail.cells.push(cell);\n            }\n        }\n        //if (!pathExists(rail.endPosition)) return false;\n        for (var i = 0; i < rail.cells.length; i++) {\n            rail.cells[i].contents.push(rail);\n        }\n        return true;\n    }\n\n    function removeRail(rail, checkIns) {\n        var path = rail.path;\n        path.check(path);\n        for (var i = path.waysOut.length - 1; i >= 0; i--) {\n            var way = path.waysOut[i];\n            if (way.railFrom == rail) {\n                path.waysOut.splice(i, 1);\n                if (way.pathTo.mergesTo &&\n                    way.pathTo.mergesTo.pathTo == path) {\n                    //DROP IT!\n                    for (var j = 0; j < path.waysIn.length; j++) {\n                        var way2 = path.waysIn[j];\n                        if (way2.pathFrom == way.pathTo) {\n                            path.waysIn.splice(j, 1);\n                            break;\n                        }\n                    }\n\n                    var seg = way.pathTo.segments;\n                    for (var i = seg.length - 1; i >= 0; i--) {\n                        removeRail(seg[i], true);\n                    }\n                } else {\n                    path.merge(way.pathTo);\n                    path.check(path);\n                    if (!build.removePath(way.pathTo)) {\n                        var k = build.finish.indexOf(path);\n                        if (k >= 0)\n                            build.finish.splice(k, 1);\n                        else {\n                            console.log(\"yes, that was the derp\");\n                        }\n                    }\n                    return;\n                }\n            }\n        }\n        path.check();\n        if (rail.mapObj) {\n            //remove objects (bridges)\n            var obj = rail.mapObj;\n            var k = build.objects.indexOf(obj);\n            if (k >= 0) {\n                grid.removeObject(obj);\n                build.objects.splice(k, 1);\n            }\n        }\n\n        //remove from cells\n        for (var i = 0; i < rail.cells.length; i++) {\n            var k = rail.cells[i].contents.indexOf(rail);\n            if (k >= 0)\n                rail.cells[i].contents.splice(k, 1);\n        }\n        //remove from path\n        path.pop();\n        if (build.canRemove(path)) {\n            var head = path.head;\n            //sometimes this head is ALREADY REMOVED. That's in case of circles\n            var oldPath = safePath(head);\n            for (var i = 0; i < oldPath.waysOut.length; i++) {\n                var way = oldPath.waysOut[i];\n                if (way.pathTo == path) {\n                    oldPath.waysOut.splice(i, 1);\n                    break;\n                }\n            }\n            build.removePath(path);\n            path.check(path);\n            //remove fucking path\n        }\n        //add removed paths\n        if (checkIns) {\n            for (var i = path.waysIn.length - 1; i >= 0; i--) {\n                var way = path.waysIn[i];\n                if (way.railTo == rail) {\n                    way.pathFrom.mergesTo = null;\n                    build.finish.push(way.pathFrom);\n                    //this wont be recursion, dont worry\n                    removeRail(way.pathFrom.tail(), true);\n                    path.waysIn.splice(i, 1);\n                }\n            }\n            path.check(path);\n        }\n    }\n\n    var q = [];\n\n    function checkLoop(path, way) {\n        while (q.length > 0) q.pop();\n        q.push(way);\n        for (var qcur = 0; qcur < q.length; qcur++) {\n            var w = q[qcur];\n            var pathTo, pos;\n            if (w.rails) {\n                pathTo = w;\n                pos = 0;\n            } else {\n                pathTo = w.pathTo;\n                pos = w.posTo;\n            }\n            if (pathTo == path) {\n                return false;\n            }\n            for (var i = 0; i < pathTo.waysOut.length; i++) {\n                var way = pathTo.waysOut[i];\n                if (way.posFrom >= pos) {\n                    if (q.indexOf(way.pathTo) < 0) {\n                        q.push(way.pathTo);\n                    }\n                }\n            }\n            if (pathTo.mergesTo) {\n                if (q.indexOf(pathTo.mergesTo) < 0)\n                    q.push(pathTo.mergesTo);\n            }\n        }\n        return true;\n    }\n\n    function addObject(obj, ignoreProblems, dontAdd) {\n        obj.cells = [];\n        if (!ignoreProblems && !dontAdd && !obj.liesInRect(rect))\n            return false;\n        var fail = grid.findIntersection(obj, function (cell) {\n            if (cell.border < 0) {\n                return !ignoreProblems && !dontAdd;\n            }\n            if (!ignoreProblems && cell.contents.length > 0) {\n                for (var i=0;i<cell.contents.length;i++) {\n                    if (cell.contents[i] != tryObjectsPrevRail)\n                        return true;\n                }\n            }\n            obj.cells.push(cell);\n            return false;\n        });\n        if (fail) return false;\n        if (!dontAdd) {\n            for (var i = 0; i < obj.cells.length; i++) {\n                obj.cells[i].contents.push(obj);\n            }\n            build.objects.push(obj);\n        }\n        return true;\n    }\n\n    var miniCounter = -1, cur = 0;\n\n    function miniCycle() {\n        if (miniCounter < 0) throw \"cant do, cycle not started\";\n        miniCounter++;\n        if (build.finish.length == 0) {\n            if (build.minLength() > minLen) {\n                best.push(build.clone());\n                minLen = build.minLength();\n            }\n            endMiniCycle();\n            return;\n        }\n        cur = (cur + 1) % build.finish.length;\n        var path = build.finish[cur];\n        var ends = 0;\n        while (path.isEnd && ends < build.finish.length) {\n            ends++;\n            cur = (cur + 1) % build.finish.length;\n            path = build.finish[cur];\n        }\n        if (ends == build.finish.length) {\n            best.push(build.clone());\n            minLen = build.minLength();\n            if (build.finish.length > 1) {\n                endMiniCycle();\n                return;\n            } else {\n                var p = path.tail();\n                p.mapObj = null;\n                removeRail(path.tail(), true);\n                for (var i = 0; i < path.isEnd.length; i++) {\n                    var obj = path.isEnd[i];\n                    var k = build.objects.indexOf(obj);\n                    if (k >= 0) {\n                        grid.removeObject(obj);\n                        build.objects.splice(k, 1);\n                    } else {\n                        var k = endRects.indexOf(obj);\n                        if (k >= 0)\n                            endRects.splice(k, 1);\n                    }\n                }\n                path.isEnd = null;\n            }\n        } else if (build.minLength() > minLen && build.finish.length >= minWays) {\n//            if (rand.quick() < 0.5)\n            if (isEnd(path)) {\n                return;\n            }\n        }\n        var tail = path.tail();\n        //TODO: what if path can be removed?\n        if (tail.tries > 0 || !path.canPop()) {\n            tail.tries--;\n            var r;\n            if (rand.quick() >= 0.5) {\n                r = path.addStraight((10 + rand.quick() * 40) | 0 * rails.h);\n            } else {\n                var sgn = rand.quick() >= 0.5 ? 1 : -1;\n                r = path.addCurve(sgn * rails.grad / 8 * ((rand.quick() * 2 | 0) + 1));\n            }\n            if (!addRail(r)) {\n                path.pop();\n                //try river or intersection\n                if (interRail != null && interRail.river && r.curve == 0) {\n                    var rivers = build.gameRes.rivers;\n                    var b = null;\n                    for (var i = 0; i < rivers.bridges.length; i++) {\n                        if (rivers.bridges[i].angle * rails.grad / 8 == r.startAngle) {\n                            b = rivers.bridges[i];\n                            break;\n                        }\n                    }\n                    if (b) {\n                        r = path.addStraight(b.len);\n                        if (!addRail(r, false, false, b.padding)) {\n                            path.pop();\n                        } else {\n                            placeBridge(r, b);\n                        }\n                    }\n                } else if (interRail != null && interRail.path &&\n                    interRail.path != path &&\n                    testParent(tail, interRail) &&\n                    build.finish.length > minWays) {\n                    tryIntersect(path, interRail);\n                }\n            } else {\n                r.tries = innerTries;\n                if (build.finish.length < maxWays && (build.finish.length < minWays || rand.quick() < 0.2))\n                    tryClone(path, tail);\n            }\n        } else {\n            removeRail(tail, true);\n        }\n    }\n\n    function placeBridge(r, b) {\n        var rivers = build.gameRes.rivers;\n        if (!b) {\n            for (var i = 0; i < rivers.bridges.length; i++) {\n                if (rivers.bridges[i].angle * rails.grad / 8 == r.startAngle) {\n                    b = rivers.bridges[i];\n                    break;\n                }\n            }\n        }\n        if (!b) return false;\n        var p = r.pointAt(b.len / 2);\n        var bm = build.gameRes.models[b.base];\n        p.x -= 189 * 0.9;\n        p.y -= 189 * 0.9;\n        r.mapObj = new FieldObject(build.gameRes.models[b.base], p, new Point(0.9, 0.9));\n        r.tries = innerTries;\n        addObject(r.mapObj, true);\n        return r.mapObj;\n    }\n\n    function testParent(rail1, rail2) {\n        if (!rail2) return true;\n        rail2 = rail2.prev;\n        if (rail2 == rail1) return false;\n        if (!rail2) return true;\n        rail2 = rail2.prev;\n        if (rail2 == rail1) return false;\n        return true;\n    }\n\n    function tryClone(path, rail) {\n        var newPath = new Path().init2(path, rail, 0);\n        var sgn = rand.quick() >= 0.5 ? 1 : -1;\n        var r2 = newPath.addCurve(sgn * rails.grad / 8 * ((rand.quick() * 2 | 0) + 1));\n        r2.tries = innerTries;\n        if (addRail(r2, false, false)) {\n            var way = new Switch().init(path, rail, rail.pos - path.head.pos, newPath, r2, 0);\n            path.waysOut.push(way);\n            build.addPath(newPath);\n        } else {\n            newPath.pop();\n            /*if (interRail != null && interRail.path && testParent(rail, interRail)) {\n             var way = new Switch().init(path, rail, rail.pos - path.head.pos, newPath, rail, 0);\n             path.waysOut.push(way);\n             //build.addPath(newPath);\n             //YEAH, lets try to remove this path\n             if (tryIntersect(newPath, interRail)) {\n             way.railTo = newPath.segments[0];\n             build.addPath(newPath);\n             } else\n             path.waysOut.pop();\n             }*/\n        }\n    }//\n\n    function safePath(railTo) {\n        var pathTo = railTo.path;\n        if (!pathTo) return false;\n        if (build.paths.indexOf(pathTo) < 0) {\n            for (var i = 0; i < build.paths.length; i++) {\n                if (build.paths[i].head == railTo) {\n                    return build.paths[i];\n                }\n            }\n            return false;\n        }\n        return pathTo;\n    }\n\n    var eps = 1e-2;\n\n    function tryIntersect(pathFrom, railTo) {\n        if (railTo.mapObj != null) return false;\n        var pathTo = safePath(railTo);\n        if (!pathTo) return false;\n        var tail = pathFrom.tail();\n        var ang1 = tail.endAngle;\n        var tries = [];\n\n        if (railTo.curve == 0)\n            tries.push(railTo);\n        var seg = pathTo.segments;\n        if (seg.length > railTo.pathIndex + 1) {\n            var r2 = seg[railTo.pathIndex + 1];\n            if (r2.curve == 0 && !r2.mapObj)\n                tries.push(r2);\n        }\n        var cosa = Math.cos(rails.angles[ang1]), sina = Math.sin(rails.angles[ang1]);\n\n        for (var t = 0; t < tries.length; t++) {\n            railTo = tries[t];\n            var ang2 = railTo.endAngle;\n            var delta = ang2 - ang1;\n            if (delta > rails.grad / 2)\n                delta -= rails.grad;\n            if (delta <= -rails.grad / 2)\n                delta += rails.grad;\n            if (delta != 0 && delta != rails.grad / 2) {\n                var r = pathFrom.addCurve(delta);\n                var p1 = r.endPosition;\n                var p2 = railTo.startPosition;\n                var dx = (p1.x - p2.x) / rails.scale.x;\n                var dy = (p1.y - p2.y) / rails.scale.y;\n\n                var cosb = Math.cos(rails.angles[ang2]), sinb = Math.sin(rails.angles[ang2]);\n\n                pathFrom.pop();\n                var len0 = cosb * dx + sinb * dy;\n                var len1 = len0 / (sina * cosb - cosa * sinb);\n                var len2 = -sinb * (dx - sina * len1) + cosb * (dy + cosa * len1);\n                if (len1 >= 0 && len2 >= 0 && len2 <= railTo.len) {\n                    var way = new Switch().init(pathFrom, tail, tail.pos - pathFrom.head.pos, pathTo, railTo,\n                        len2 + (railTo.pos - railTo.len - pathTo.head.pos));\n                    if (!checkLoop(pathFrom, way)) continue;\n                    if (len1 > eps) {\n                        var endRail0 = pathFrom.addStraight(len1);\n                        endRail0.tries = 0;\n                        if (!addRail(endRail0)) {\n                            pathFrom.pop();\n                            continue;\n                        }\n                    }\n                    var endRail = pathFrom.addCurve(delta);\n                    addRail(endRail, true);//\n                    way.posFrom = endRail.pos - pathFrom.head.pos;\n                    way.railFrom = endRail;\n                    var k = build.finish.indexOf(pathFrom);\n                    if (k >= 0) build.finish.splice(k, 1);\n                    pathFrom.mergesTo = way;\n                    pathTo.waysIn.push(way);\n                    //TODO: close it!\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    var canPlaceAfter = false;\n    function placeRiver() {\n        var prevRiver = prevBuilder.objects[0];\n        var r1 = prevRiver ? prevRiver.name : \"\";\n        var r = build.gameRes.rivers;\n        if (r1.substring(0, 5) == \"river\") {\n            var s = 0;\n            for (var i = 0; i < r.water.length; i++) {\n                for (var j = 0; j + 1 < r.water[i].list.length; j++)\n                    if (r.water[i].list[j].model == r1) {\n                        s = r.water[i].list[j + 1];\n                    }\n            }\n            if (s) {\n                var obj = new FieldObject(build.gameRes.models[s.model], new Point(prevRiver.position.x + s.shiftX, s.shiftY || 0), new Point(1, 1));\n                addObject(obj, true);\n                obj.cells.forEach(function(cell) {\n                    cell.contents.forEach(function(rail) {\n                        if (!rail.path) return;\n                        if (rail.mapObj) return;\n                        placeBridge(rail);\n                    });\n                });\n\n                obj.river = true;\n                return obj;\n            }\n        }\n        if (!hasRiver) return false;\n        var sum = 0;\n        for (var i=0;i< r.water.length;i++) {\n            sum += r.water[i].p;\n        }\n        var tt = Math.random() * sum | 0;\n        var ind = 0;\n        while (tt>= r.water[ind].p) {\n            tt-= r.water[ind++].p;\n        }\n        var s = r.water[ind].list[0];\n        var obj = new FieldObject(build.gameRes.models[s.model], new Point(rect.x + (s.shiftX || 0), s.shiftY || 0), new Point(1, 1));\n        if (addObject(obj, false, true)) {\n            addObject(obj, true);\n            obj.river = true;\n            return obj;\n        }\n        return false;\n    }\n\n    function beginMiniCycle() {\n        self.tries++;\n        build.clear();\n        grid.clear();\n        build.addToGrid(grid);\n        var river = placeRiver();\n        canPlaceAfter = (!river || river.getBounds().x + river.getBounds().width < rect.x + rect.width);\n        build.highway = (canPlaceAfter && Math.random() < highwayProb) ? (rect.x + rect.width) : 0;\n        while (endRects.length > 0) endRects.pop();\n        miniCounter = 0;\n    }\n\n    function endMiniCycle() {\n        miniCounter = -1;\n    }\n\n    function cycle() {\n        beginMiniCycle();\n        for (var tr = 0; tr < recTries && miniCounter >= 0; tr++) {\n            miniCycle();\n        }\n        endMiniCycle();\n    }\n\n    var best = [];\n    var objects;\n    var build = new Builder();\n    build.init2(prevBuilder, rect);\n\n    self.tries = 0;\n\n    this.doIt = function (tries, tryUntilSuccess) {\n        var dt = Date.now();\n        var tr;\n        for (tr = 0; self.tries < tries || tryUntilSuccess && best.length == 0; tr++) {\n            cycle();\n        }\n        dt = Date.now() - dt;\n        if (tr > 1)\n            console.log(\"generation \" + tr + \" tries, \" + dt + \" ms\");\n    }\n\n    this.doIt2 = function (counter) {\n        for (var i = 0; i < counter; i++) {\n            if (miniCounter < 0 || miniCounter >= recTries) beginMiniCycle();\n            miniCycle();\n        }\n    }\n\n\n    this.resetIfNoWay = function () {\n        self.tries = 0;\n        self.best = [];\n        endMiniCycle();\n    }\n\n    this.finish = function () {\n        if (best.length == 0) return false;\n        var dt = Date.now();\n\n        //popping best variant\n        var TEMP = build;\n        endMiniCycle();\n        var RES = build = best.pop();\n        while (best.length > 0 && best[best.length - 1].minLength() > minLen - 5) best.pop();\n        minLen = best.length > 0 ? best[best.length - 1].minLength() : 0;\n\n        build.shiftX = rect.x + rect.width;\n        grid.clear();\n        for (var i = 0; i < build.finish.length; i++) {\n            var tail = build.finish[i].tail();\n            var endAngle = tail.endAngle;\n            build.shiftX = Math.min(build.shiftX, Math.round(tail.startPosition.x));\n        }\n        if (build.highway) {\n            build.shiftX = rect.x + rect.width + highwayWidth;\n        }\n        var bshiftX = Math.min(build.shiftX, rect.x + rect.width);\n        build.addToGrid(grid);\n        var clusters = build.gameRes.clusters;\n        var models = build.gameRes.models;\n\n        var roster = [];\n        for (var i = 0; i < clusters.length; i++) roster.push(clusters[i]);\n        if (roster.length > 0)\n            roster.splice(Math.random() * roster.length | 0, 1);\n        for (var i = 0; i < objectsCount; i++) {\n            var cluster = roster[rand.quick() * roster.length | 0];\n            var modelName = cluster.main[rand.quick() * cluster.main.length | 0];\n            var model = models[modelName];\n            var p = null;\n            var tr = cluster.tries || 10;\n            cycle1:for (var j = 0; j < tr; j++) {\n                //var scale = rand.quick() * 0.05 + 0.3;\n                var scale = model.density || 1;\n                var p1 = new Point(rand.quick() * (bshiftX - rect.x) + rect.x,\n                    rand.quick() * rect.height + rect.y);\n                var p2 = new Point(Math.round(p1.x - model.anchor.x * scale), Math.round(p1.y - model.anchor.y * scale));\n\n                if (cluster.neibRadius) {\n                    for (var i = 0; i < build.objects.length; i++) {\n                        if (build.objects[i].name == modelName) {\n                            var dx = build.objects[i].position.x - p2.x;\n                            var dy = build.objects[i].position.y - p2.y;\n                            if (dx * dx + dy * dy < cluster.neibRadius * cluster.neibRadius) continue cycle1;\n                        }\n                    }\n                }\n                var obj = new FieldObject(model, p2, new Point(scale, scale));\n                if (addObject(obj)) {\n                    obj.name = modelName;\n                    p = p1;\n                    break;\n                }\n            }\n            if (!p || !cluster.secondary) continue;\n            if (cluster.once) {\n                roster.splice(roster.indexOf(cluster), 1);\n            }\n            //place cluster!\n            for (var i = 0; i < cluster.secondary.length; i++) {\n                var total = 0;\n                var s = cluster.secondary[i];\n                for (var tr = 0; tr < s.tries && total < s.count; tr++) {\n                    var modelName2 = s.list[rand.quick() * s.list.length | 0];\n                    var model2 = models[modelName2];\n                    var scale = model2.density || 1;\n\n                    var r = Math.random() * (s.radMax - s.radMin) + s.radMin;\n                    var alpha = Math.random() * Math.PI * 2;\n\n                    var p1 = new Point(p.x + Math.cos(alpha) * r, p.y + Math.sin(alpha) * r);\n                    var p2 = new Point(Math.round(p1.x - model2.anchor.x * scale), Math.round(p1.y - model2.anchor.y * scale));\n                    var obj = new FieldObject(model2, p2, new Point(scale, scale));\n                    if (addObject(obj)) {\n                        obj.name = modelName2;\n                        total++;\n                    }\n                }\n            }\n        }\n        build.initLinkedList();\n        dt = Date.now() - dt;\n        console.log(\"generation objects \" + dt + \" ms\");\n        build = TEMP;\n        return RES;\n    }\n};\n","var Point = require('./pixi/Point');\r\nvar Rectangle = require('./pixi/Rectangle');\r\n\r\nfunction Cell(row, col, border, rect) {\r\n    this.row = row;\r\n    this.col = col;\r\n    this.border = border;\r\n    this.rect = rect;\r\n    this.sid = 0;\r\n    this.contents = [];\r\n}\r\n\r\n//random placing function\r\nfunction Grid(options) {\r\n    this.tileW = options.tileW || 32;\r\n    this.tileH = options.tileH || 32;\r\n    var rect = this.rect = options.rect || new Rectangle(0, 0, 1280, 720);\r\n    this.border = options.border || 1;\r\n\r\n    this.w = Math.ceil(rect.width / this.tileW) + 2 * this.border;\r\n    this.h = Math.ceil(rect.height / this.tileH) + 2 * this.border;\r\n\r\n    this.grid = [];\r\n    for (var j = 0; j < this.h; j++) {\r\n        var row = [];\r\n        for (var i=0; i < this.w; i++) {\r\n            var ii = i - this.border, jj = j - this.border;\r\n            row.push(new Cell(jj, ii, Math.min(Math.min(ii, this.w - this.border - i-1), Math.min(jj, this.h - this.border - j-1)),\r\n                new Rectangle(ii*this.tileW + rect.x, jj*this.tileH + rect.y, this.tileW, this.tileH)));\r\n        }\r\n        this.grid.push(row);\r\n    }\r\n}\r\n\r\nGrid.prototype = {\r\n    cellAt : function(x, y) {\r\n        x -= this.rect.x;\r\n        y -= this.rect.y;\r\n        x = Math.floor(x / this.tileW) + this.border;\r\n        y = Math.floor(y / this.tileH) + this.border;\r\n        if (x<0 || x>=this.w || y<0 || y>=this.h)\r\n            return null;\r\n        return this.grid[y][x];\r\n    },\r\n    addObject: function(obj) {\r\n        obj.cells = [];\r\n        this.findIntersection(obj, function(cell) {\r\n            if (cell.border>=0) {\r\n                cell.contents.push(obj);\r\n                obj.cells.push(cell);\r\n            }\r\n            return false;\r\n        })\r\n    },\r\n    removeObject: function(obj) {\r\n        this.findIntersection(obj, function(cell) {\r\n            if (cell.border>=0) {\r\n                var k = cell.contents.indexOf(obj);\r\n                if (k>=0)\r\n                    cell.contents.splice(k, 1);\r\n            }\r\n            return false;\r\n        })\r\n    },\r\n    clear: function() {\r\n        var grid = this.grid;\r\n        for (var i=0;i<grid.length;i++)\r\n            for (var j=0;j<grid[i].length;j++) {\r\n                var cell = grid[i][j];\r\n                while (cell.contents.length>0)\r\n                    cell.contents.pop();\r\n            }\r\n    },\r\n    findIntersection: function(obj, callback) {\r\n        var bounds = obj.getBounds(), rect = this.rect;\r\n        var i1 = Math.floor((bounds.x - rect.x) / this.tileW);\r\n        var i2 = Math.ceil((bounds.x - rect.x+ bounds.width ) / this.tileW);\r\n        var j1 = Math.floor((bounds.y - rect.y) / this.tileH);\r\n        var j2 = Math.ceil((bounds.y - rect.y + bounds.height) / this.tileH);\r\n        i1+=this.border;\r\n        j1+=this.border;\r\n        if (i1<0) i1 = 0;\r\n        if (i2>=this.w) i2 = this.w-1;\r\n        if (j1<0) j1 = 0;\r\n        if (j2>=this.h) j2 = this.h-1;\r\n        for (var i=i1;i<=i2;i++)\r\n            for (var j=j1;j<=j2;j++) {\r\n                var cell = this.grid[j][i];\r\n                if (obj.intersectRect(cell.rect))\r\n                    if (callback) {\r\n                        var cb = callback(cell);\r\n                        if (cb) return cb;\r\n                    } else {\r\n                        if (cell.contents.length>0 || cell.border<0)\r\n                            return true;\r\n                    }\r\n            }\r\n        return false;\r\n    }\r\n    /*\r\n     //TODO: move into grid\r\n     var q = [], id = 0;\r\n     var dx = [1, 0, -1, 0], dy = [0, 1, 0, -1];\r\n     function pathExists(p) {\r\n     id++;\r\n     var start = grid2.cellAt(p.x, p.y);\r\n     var end = grid2.cellAt(endPos.x, endPos.y);\r\n     while (q.length>0) q.pop();\r\n     q.push(start);\r\n     start.pid = id;\r\n     for (var i=0;i< q.length;i++) {\r\n     var cell = q[i];\r\n     if (cell == end) return true;\r\n     if (cell.border<0) continue;\r\n     for (var j=0;j<4;j++) {\r\n     var row2 = cell.row  + dx[j];\r\n     var col2 = cell.col  + dy[j];\r\n     var next = grid2.grid[row2 + grid2.border][col2 + grid2.border];\r\n     if (next.pid == id || next.border<0 || next.contents.length>0)\r\n     continue;\r\n     if (next == end) return true;\r\n     next.pid = id;\r\n     q.push(next);\r\n     }\r\n     }\r\n     return false;\r\n     }*/\r\n}\r\n\r\nmodule.exports = Grid;\r\n","/**\r\n * Created by Liza on 31.07.2015.\r\n */\r\n\r\nvar Point = require('./pixi/Point');\r\nvar Rectangle = require('./pixi/Rectangle');\r\nvar Rails = require('./Rails');\r\nvar Path = require('./Path');\r\nvar FieldObject = require('./FieldObject');\r\nvar Generator = require('./Generator');\r\nvar Builder = require('./Builder');\r\n\r\nfunction Level(gameRes, listener) {\r\n    gameRes.initModels();\r\n    //init models\r\n    this.gameRes = gameRes;\r\n    this.options = gameRes.options;\r\n    this.rails = gameRes.rails;\r\n    this.patches = [];\r\n    this.gen = null;\r\n    this.prevGen = null;\r\n    this.listener = listener || null;\r\n    this.start();\r\n}\r\n\r\nmodule.exports = Level;\r\nLevel.prototype = {\r\n    start: function() {\r\n        var gameRes = this.gameRes;\r\n        var rails = gameRes.rails;\r\n        var options = gameRes.options;\r\n        var patch = new Builder();\r\n        patch.init1(gameRes, new Path().init1(rails, new Point(0, options.height/2), rails.grad * 6/8, options.wayLen), false);\r\n        if (options.startWays == 2) {\r\n            var path = new Path().init1(rails, new Point(0, 220), rails.grad * 6/8, options.wayLen);\r\n            patch.paths.push(path);\r\n            patch.start++;\r\n            patch.finish.push(path);\r\n        }\r\n        this.addPatch(patch);\r\n        return this;\r\n    },\r\n    addPatch: function(patch) {\r\n        this.patches.push(patch);\r\n        this.prevGen = this.gen;\r\n        this.initGen();\r\n        if (this.listener) {\r\n            this.listener.addPatch(patch);\r\n        }\r\n        this.removed = false;\r\n    },\r\n    removeFront: function() {\r\n        this.patches.pop();\r\n        this.gen = this.prevGen;\r\n        this.prevGen = null;\r\n        if (!this.gen) this.initGen();//\r\n        if (this.listener) {\r\n            this.listener.removeFront();\r\n        }\r\n        this.removed = true;\r\n    },\r\n    tail: function(index) {\r\n        return this.patches[this.patches.length-1-(index|0)];\r\n    },\r\n    initGen: function() {\r\n        var patch = this.tail();\r\n        if (!patch) return;\r\n        var options = this.options;\r\n        this.gen = new Generator(patch, {\r\n            rect: new Rectangle(patch.shiftX, 0, options.width, options.height),\r\n            rect2: new Rectangle(patch.shiftX, options.topOffset, options.width, options.height - options.bottomOffset - options.topOffset),\r\n            endStation: options.endStation,\r\n            endLen: 50,\r\n            minWays: options.minWays,\r\n            maxWays: options.maxWays,\r\n            intersections: options.intersections,\r\n            topOffset: options.topOffset,\r\n            clusters : options.clusters\r\n        });\r\n    },\r\n    addPatchForSure: function() {\r\n        var gen = this.gen;\r\n        gen.doIt(30, this.removed);\r\n        var patch = gen.finish();\r\n        if (!patch) {\r\n            if (this.patches.length>1) {\r\n                this.removeFront();\r\n                this.addPatchForSure();\r\n                this.addPatchForSure();\r\n            } else {\r\n                gen.tries = 0;\r\n                this.addPatchForSure();\r\n            }\r\n        } else {\r\n            this.addPatch(patch);\r\n        }\r\n    },\r\n    removeBack: function(cb) {\r\n        this.patches.shift();\r\n        this.patches[0].cutHead();\r\n        this.genSync(4, cb);\r\n    },\r\n    genSync: function(s, cb) {\r\n        while (this.patches.length<(s||5)) {\r\n            this.addPatchForSure();\r\n        }\r\n        cb && cb();\r\n    },\r\n    doIt2 : function(cycles) {\r\n        var options = this.options;\r\n        if (this.patches.length>=options.lazyPatches) return false;\r\n        var gen = this.gen;\r\n        gen.doIt2(cycles);\r\n        if (gen.tries>30) {\r\n            var patch = gen.finish();\r\n            if (!patch) {\r\n                if (!this.removed)\r\n                    this.removeFront();\r\n                this.gen.resetIfNoWay();\r\n                this.genSync();\r\n            } else\r\n                this.addPatch(patch);\r\n        }\r\n        return true;\r\n    }\r\n}\r\n","var Point = require('./pixi/Point');\r\nvar Rails = require('./Rails');\r\nvar Segment = require('./Segment');\r\nvar Switch = require('./Switch');\r\nvar FieldObject = require('./FieldObject');\r\n\r\nfunction Path() {\r\n    this.segments = [];\r\n    this.waysIn = [];\r\n    this.waysOut = [];\r\n};\r\n\r\nPath.prototype = {\r\n    id: 0,\r\n    length: 0,\r\n    headPos: 0,\r\n    rails: null,\r\n    head: null,\r\n    mergesTo: null,\r\n    segPool: [],\r\n    isStart: function() {\r\n        return this.head.path == this;\r\n    },\r\n    clear: function() {\r\n        var seg = this.segments;\r\n        while (seg.length>0) seg.pop();\r\n        if (this.head && this.head.path == this) {\r\n            this.length = this.head.len;\r\n        } else\r\n            this.length = 0;\r\n        this.isEnd = null;\r\n        this.mergesTo = null;\r\n        while (this.waysIn.length>0)\r\n            this.waysIn.pop();\r\n        while (this.waysOut.length>0)\r\n            this.waysOut.pop();\r\n    },\r\n    cutHead: function() {\r\n        if (this.head.path == this) return;\r\n        this.head.path = this;\r\n        this.head.prev = null;\r\n        this.segments.unshift(this.head);\r\n        this.length += this.head.len;\r\n    },\r\n    tail: function(index) {\r\n        var ind = this.segments.length-1-(index|0);\r\n        return ind>=0 ? this.segments[ind]: this.head;\r\n    },\r\n    init1: function(rails, startPosition, startAngle, startLen) {\r\n        this.id = ++rails.incrementId;\r\n        var seg = this.segments;\r\n        while (seg.length>0) seg.pop();\r\n        this.clear();\r\n        this.rails = rails;\r\n        this.head = rails.createStraight(startPosition, startAngle, startLen || rails.h, this.segPool.length > 0 ? this.segPool.pop() : null);\r\n        this.head.path = this;\r\n        seg.push(this.head);\r\n        this.length = this.head.len;\r\n        return this;\r\n    },\r\n    check: function() {\r\n       /* for (var i=0;i<this.waysOut.length;i++) {\r\n            var way = this.waysOut[i];\r\n            if (way.railFrom.endPosition.x != way.railTo.startPosition.x) {\r\n                console.log(\"derping\");\r\n            }\r\n        }*/\r\n    },\r\n    init2: function(prevPath, rail, pos) {\r\n        var seg = this.segments;\r\n        while (seg.length>0) seg.pop();\r\n        this.head = rail || prevPath.tail();\r\n        this.headPos = pos || 0;\r\n        this.rails = prevPath.rails;\r\n        this.id = ++this.rails.incrementId;\r\n        return this;\r\n    },\r\n    add: function(rail) {\r\n        var seg = this.segments;\r\n        rail.prev = this.tail();\r\n        rail.path = this;\r\n        rail.pathIndex = seg.length;\r\n        rail.pos = rail.prev.pos + rail.len;\r\n        this.length += rail.len;\r\n        seg.push(rail);\r\n    },\r\n    addCurve: function(angle) {\r\n        var tail = this.tail();\r\n        var r = this.rails.createCurve(tail.endPosition, tail.endAngle, angle, this.segPool.length>0?this.segPool.pop(): null);\r\n        this.add(r);\r\n        return r;\r\n    },\r\n    addStraight: function(segments) {\r\n        var tail = this.tail();\r\n        var r = this.rails.createStraight(tail.endPosition, tail.endAngle, segments, this.segPool.length>0?this.segPool.pop(): null);\r\n        this.add(r);\r\n        return r;\r\n    },\r\n    pop: function() {\r\n        var tail = this.segments.pop();\r\n        this.length -= tail.len;\r\n        tail.init(null);\r\n        this.segPool.push(tail);\r\n    },\r\n    canPop: function() {\r\n        return this.segments.length > 1 || this.segments.length == 1 && !this.isStart();\r\n    },\r\n    clone: function() {\r\n        var b = new Path();\r\n        b.id = this.id;\r\n        b.rails = this.rails;\r\n        var seg = this.segments;\r\n        for (var i=0;i<seg.length;i++) {\r\n            var segment = seg[i].clone();\r\n            segment.path = b;\r\n            b.segments.push(segment);\r\n        }\r\n        b.head = this.isStart()? b.segments[0]: this.head;\r\n        for (var i=0;i<this.waysIn.length;i++) {\r\n            var oldWay = this.waysIn[i];\r\n            var newWay = oldWay.clone();\r\n            newWay.pathTo = b;\r\n            //newWay.railTo = b.segments[oldWay.railTo.pathIndex];\r\n            b.waysIn.push(newWay);\r\n        }\r\n        for (var i=0;i<this.waysOut.length;i++) {\r\n            var oldWay = this.waysOut[i];\r\n            var newWay = oldWay.clone();\r\n            newWay.pathFrom = b;\r\n            //newWay.railFrom = b.segments[oldWay.railFrom.pathIndex];\r\n            b.waysOut.push(newWay);\r\n        }\r\n        return b;\r\n    },\r\n    merge: function(path) {\r\n        var tail = this.tail();\r\n        var seg = path.segments;\r\n        for (var i=0;i<seg.length;i++)\r\n            this.add(seg[i]);\r\n        var ins = path.waysIn;\r\n        for (var i=0;i<ins.length;i++) {\r\n            var way = ins[i];\r\n            way.posTo += tail.pos - this.head.pos;\r\n            way.pathTo = this;\r\n            this.waysIn.push(way);\r\n        }\r\n        var outs = path.waysOut;\r\n        for (var i=0;i<outs.length;i++) {\r\n            var way = outs[i];\r\n            way.pathFrom = this;\r\n            way.posFrom += tail.pos - this.head.pos;\r\n            this.waysOut.push(way);\r\n        }\r\n        this.isEnd = path.isEnd;\r\n        if (path.mergesTo) {\r\n            this.mergesTo = path.mergesTo;\r\n            this.mergesTo.pathFrom = this;\r\n        }\r\n    },\r\n    toJson: function() {\r\n        return {\r\n            id: this.id,\r\n            waysIn: this.waysIn.map(toJson),\r\n            waysOut: this.waysOut.map(toJson),\r\n            segments: this.segments.map(toJson),\r\n            head: this.head.id\r\n        }\r\n    },\r\n    fromJson: function(json, rails) {\r\n        var self = this;\r\n        this.rails = rails;\r\n        this.id = json.id;\r\n        this.head = json.head;\r\n        this.waysIn = json.waysIn.map(switchReader);\r\n        this.waysOut = json.waysOut.map(switchReader);\r\n        this.segments = json.segments.map(function(obj) { return new Segment().fromJson(obj, self); });\r\n        return this;\r\n    },\r\n    fromJsonStep2: function(segments, paths) {\r\n        this.head = segments[this.head];\r\n        for (var i=0;i<this.waysIn.length;i++) {\r\n            var way = this.waysIn[i];\r\n            way.pathFrom = paths[way.pathFrom];\r\n            way.railFrom = segments[way.railFrom];\r\n            way.pathTo = paths[way.pathTo];\r\n            way.railTo = segments[way.railTo];\r\n        }\r\n        for (var i=0;i<this.waysOut.length;i++) {\r\n            var way = this.waysOut[i];\r\n            way.pathFrom = paths[way.pathFrom];\r\n            way.railFrom = segments[way.railFrom];\r\n            way.pathTo = paths[way.pathTo];\r\n            way.railTo = segments[way.railTo];\r\n        }\r\n    },\r\n    saveBin: function(buffer) {\r\n        var save = function(x){x.saveBin(buffer);};\r\n        buffer.writeInt(this.id);\r\n        buffer.writeInt(this.head.id);\r\n        buffer.writeInt(this.segments.length);\r\n        this.segments.forEach(save);\r\n        buffer.writeInt(this.waysIn.length);\r\n        this.waysIn.forEach(save);\r\n        buffer.writeInt(this.waysOut.length);\r\n        this.waysOut.forEach(save);\r\n    },\r\n    loadBin: function(buffer) {\r\n        this.id = buffer.readInt();\r\n        this.head = buffer.readInt();\r\n        for (var i=buffer.readInt();i>0;i--) this.segments.push(new Segment().loadBin(buffer, this));\r\n        for (var i=buffer.readInt();i>0;i--) this.waysIn.push(new Switch().loadBin(buffer, this));\r\n        for (var i=buffer.readInt();i>0;i--) this.waysOut.push(new Switch().loadBin(buffer, this));\r\n        return this;\r\n    }\r\n};\r\n\r\nvar toJson = function(obj) {return obj.toJson(); };\r\nvar switchReader = function(obj) { return new Switch().copy(obj) }\r\n\r\nmodule.exports = Path;\r\n","/**\r\n * Created by Liza on 20.07.2015.\r\n */\r\nvar Point = require('./pixi/Point');\r\nvar Rectangle = require('./pixi/Rectangle');\r\nvar FieldObject = require('./FieldObject');\r\nvar Segment = require('./Segment');\r\n\r\nfunction Rails(radius, scale, grad, w, h) {\r\n    if (radius) this.init(radius, scale, grad, w, h);\r\n}\r\n\r\nRails.prototype = {\r\n    init: function(radius, scale, grad, w, h) {\r\n        //for visual representation: collection of resource names, anchor points and scales\r\n        this.radius = radius = radius || 72;\r\n        this.grad = grad = grad || 8;\r\n        this.w = w || 3;\r\n        this.h = h || (radius * Math.PI * 2 / grad);\r\n        this.rr = [radius, radius - w, radius + w, radius -w*2, radius + w*2];\r\n        this.scale = scale = scale || new Point(1, 2/3);\r\n        this.angles = [];\r\n        // ,    \r\n        for (var i=0;i<grad;i++) {\r\n            var a = i / grad * 2 * Math.PI;\r\n            //this.angles.push(180 / Math.PI * Math.atan2(Math.sin(a) * scale.y / scale.x, Math.cos(a)));\r\n            this.angles.push(a);\r\n        }\r\n        this.visuals = {};\r\n\r\n        this.radii = [];\r\n        for (var j=0; j<this.rr.length;j++) {\r\n            this.radii.push([]);\r\n        }\r\n        for (var i=0;i<grad;i++) {\r\n            var ang = this.angles[i];\r\n            var cosa = Math.cos(ang);\r\n            var sina = Math.sin(ang);\r\n            for (var j=0;j<this.rr.length;j++) {\r\n                var r = this.rr[j];\r\n                this.radii[j].push(this.roundPoint(r * cosa, r * sina));\r\n            }\r\n        }\r\n    },\r\n    incrementId: 0,\r\n    roundPoint: function(x, y) {\r\n        //return new Point(Math.round(x * this.scale.x), Math.round(y * this.scale.y));\r\n        return new Point(x * this.scale.x, y * this.scale.y);\r\n    },\r\n    createStraight: function(startPosition, startAngle, len, seg) {\r\n        seg = seg || new Segment();\r\n        seg.init(this);\r\n\r\n        var scale = this.scale;\r\n        seg.segmentCount = Math.round(len / this.h);\r\n        seg.curve = 0;\r\n        if (seg.segmentCount<1) seg.segmentCount = 1;\r\n        var ang = (this.angles[startAngle] + Math.PI/2) ;\r\n        var cosa = Math.cos(ang);\r\n        var sina = Math.sin(ang);\r\n        seg.startPosition.x = startPosition.x;\r\n        seg.startPosition.y = startPosition.y;\r\n        seg.startAngle = startAngle;\r\n        seg.endPosition.x = startPosition.x + len * cosa * scale.x;\r\n        seg.endPosition.y = startPosition.y + len * sina * scale.y;\r\n        seg.endAngle = startAngle;\r\n        seg.pos = seg.len = len;\r\n        seg.id = ++this.incrementId;\r\n        return seg;\r\n    },\r\n    createCurve: function(startPosition, startAngle, deltaAngle, seg) {\r\n        seg = seg || new Segment();\r\n        seg.init(this);\r\n\r\n        var scale = this.scale;\r\n        seg.startAngle = startAngle;\r\n        var endAngle = seg.endAngle = (startAngle + deltaAngle + this.grad) % this.grad;\r\n        var curve = seg.curve = deltaAngle>0?1:-1;\r\n        if (deltaAngle == 0) throw \"curve deltaAngle must != 0\";\r\n        seg.centerPosition.x = startPosition.x - this.radii[0][startAngle].x * curve;\r\n        seg.centerPosition.y = startPosition.y - this.radii[0][startAngle].y * curve;\r\n        seg.startPosition.x = startPosition.x;\r\n        seg.startPosition.y = startPosition.y;\r\n        seg.endPosition.x = startPosition.x - (this.radii[0][startAngle].x - this.radii[0][endAngle].x) * curve;\r\n        seg.endPosition.y = startPosition.y - (this.radii[0][startAngle].y - this.radii[0][endAngle].y) * curve;\r\n        seg.segmentCount = Math.abs(deltaAngle);\r\n        var tt = this.angles[endAngle] - this.angles[startAngle];\r\n        if (curve<0) tt = -tt;\r\n        if (tt<0) tt+=2 * Math.PI;\r\n        seg.pos = seg.len = this.radius * tt;\r\n        seg.id = ++this.incrementId;\r\n        return seg;\r\n    },\r\n    addVisualStroke: function(obj) {\r\n        this.visuals[\"stroke\"] = obj;\r\n    },\r\n    toJson: function() {\r\n        return {\r\n            radius: this.radius,\r\n            scale: this.scale,\r\n            grad: this.grad,\r\n            w: this.w,\r\n            h: this.h\r\n        }\r\n    },\r\n    fromJson: function(json) {\r\n        this.init(json.radius, json.scale, json.grad, json.w, json.h);\r\n        return this;\r\n    }\r\n};\r\n\r\nmodule.exports = Rails;\r\n","/**\r\n * Created by Liza on 02.08.2015.\r\n */\r\n\r\nvar Point = require('./pixi/Point');\r\nvar Rectangle = require('./pixi/Rectangle');\r\n\r\nfunction Segment() {\r\n    this.centerPosition = new Point();\r\n    this.startPosition = new Point();\r\n    this.endPosition = new Point();\r\n}\r\n\r\nvar temp = new Point(), temp2 = new Point();\r\nmodule.exports = Segment;\r\n\r\nSegment.prototype = {\r\n    id: 0,\r\n    curve: 0,\r\n    len: 0,\r\n    segmentCount: 0,\r\n    rails: 0,\r\n    prev: 0,\r\n    next: 0,\r\n    nextPos: 0,\r\n    centerPosition: new Point(),\r\n    startPosition: new Point(),\r\n    endPosition: new Point(),\r\n    startAngle: 0,\r\n    endAngle: 0,\r\n    isEnd : false,\r\n    highwayPos: 0,\r\n    init: function(rails) {\r\n        this.rails = rails;\r\n        this.positions = null;\r\n        this.bounds = null;\r\n        this.cells = null;\r\n        this.prev = null;\r\n        this.pos = 0;\r\n\r\n        this.path = null;\r\n        this.pathIndex = 0;\r\n        this.nextPos = 0;\r\n        this.next = null;\r\n        this.isEnd = false;\r\n        this.mapObj = null;\r\n        this.highwayPos = 0;\r\n    },\r\n    copy: function(seg) {\r\n        this.init(seg.rails);\r\n        this.centerPosition.x = seg.centerPosition.x;\r\n        this.centerPosition.y = seg.centerPosition.y;\r\n        this.startPosition.x = seg.startPosition.x;\r\n        this.startPosition.y = seg.startPosition.y;\r\n        this.endPosition.x = seg.endPosition.x;\r\n        this.endPosition.y = seg.endPosition.y;\r\n        this.len = seg.len;\r\n        this.curve = seg.curve;\r\n        this.segmentCount = seg.segmentCount;\r\n        this.startAngle = seg.startAngle;\r\n        this.endAngle = seg.endAngle;\r\n        this.id = seg.id;\r\n        this.pos = seg.pos;\r\n        this.mapObj = seg.mapObj;\r\n        this.highwayPos = seg.highwayPos;\r\n\r\n    },\r\n    clone: function(seg) {\r\n        var seg = new Segment();\r\n        seg.copy(this);\r\n        return seg;\r\n    },\r\n    isTangent: function() {\r\n        return this.curve != 0;\r\n    },\r\n    pointAt: function(param, p3) {\r\n        var rails = this.rails;\r\n        p3 = p3 || new Point();\r\n        var radius = rails.radius, scale = rails.scale;\r\n        if (param<0) param = 0;\r\n        if (param > this.len) param = this.len;\r\n        var s = param / this.len;\r\n        if (this.curve == 0) {\r\n            //straight\r\n            var p1 = this.startPosition, p2 = this.endPosition;\r\n            p3.x = p1.x + (p2.x-p1.x) * s;\r\n            p3.y = p1.y + (p2.y-p1.y) * s;\r\n            return p3;\r\n        } else {\r\n            var p = this.centerPosition;\r\n            var ang = rails.angles[this.startAngle] + this.curve * (param / radius);\r\n            if (this.curve<0) ang += Math.PI;\r\n            p3.x = p.x + Math.cos(ang) * radius * scale.x;\r\n            p3.y = p.y + Math.sin(ang) * radius * scale.y;\r\n            return p3;\r\n        }\r\n    },\r\n    pointAtRail: function(param, num, p3) {\r\n        p3 = p3 || new Point();\r\n        if (param<0) param = 0;\r\n        if (param > this.len) param = this.len;\r\n        var s = param / this.len;\r\n        var seg = this.segmentCount * s | 0;\r\n        if (seg >= this.segmentCount) seg = this.segmentCount - 1;\r\n        var s2 = this.segmentCount * s - seg;\r\n        this.getPoint(num, seg, temp);\r\n        this.getPoint(num, seg+1, temp2);\r\n        p3.x = temp.x * (1-s2) + temp2.x * s2;\r\n        p3.y = temp.y * (1-s2) + temp2.y * s2;\r\n        return p3;\r\n    },\r\n    fillPositions: function(pos, startFrom) {\r\n        startFrom = startFrom || 0;\r\n        var startAngle = this.startAngle;\r\n        var startPosition = this.startPosition;\r\n        var centerPosition = this.centerPosition;\r\n        var len = this.len;\r\n        var segmentCount = this.segmentCount;\r\n        var rails = this.rails;\r\n        var scale = rails.scale;\r\n        var radii = rails.radii;\r\n        var grad = rails.grad;\r\n        var curve = this.curve;\r\n        if (curve==0) {\r\n            var ang = (rails.angles[startAngle] + Math.PI/2);\r\n            var cosa = Math.cos(ang);\r\n            var sina = Math.sin(ang);\r\n            for (var j=startFrom;j<5;j++) {\r\n                var sx = startPosition.x - radii[0][startAngle].x + radii[j][startAngle].x;\r\n                var sy = startPosition.y - radii[0][startAngle].y + radii[j][startAngle].y;\r\n                var dx = len / segmentCount * cosa * scale.x;\r\n                var dy = len / segmentCount * sina * scale.y;\r\n                for (var i=0;i<=segmentCount;i++) {\r\n                    pos.push(sx);\r\n                    pos.push(sy);\r\n                    sx += dx;\r\n                    sy += dy;\r\n                }\r\n            }\r\n        } else {\r\n            for (var j=startFrom;j<5;j++) {\r\n                var sx = centerPosition.x;\r\n                var sy = centerPosition.y;\r\n                var jj = j;\r\n                if (curve<0 && j>0) {\r\n                    if (j%2==1) jj++;\r\n                    else jj--;\r\n                }\r\n                for (var i=0;i<=segmentCount;i++) {\r\n                    var ang = (startAngle + i * curve + grad*7/4 + curve * grad/4) % grad;\r\n                    pos.push(sx + radii[jj][ang].x);\r\n                    pos.push(sy + radii[jj][ang].y);\r\n                }\r\n            }\r\n        }\r\n        return pos;\r\n    },\r\n    getPoint : function(ind1, ind2, point) {\r\n        if (!this.positions) {\r\n            this.positions = this.fillPositions([]);\r\n        }\r\n        point.x = this.positions[(ind1*(this.segmentCount+1) + ind2)*2];\r\n        point.y = this.positions[(ind1*(this.segmentCount+1) + ind2)*2+1];\r\n    },\r\n    calcBounds: function() {\r\n        if (!this.bounds) this.bounds = new Rectangle();\r\n        var p = this.startPosition;\r\n        var minX = p.x, maxX = p.x, minY = p.y, maxY = p.y;\r\n        var segmentCount = this.segmentCount;\r\n        var pos = this.positions;\r\n        for (var j=3; j<5; j++)\r\n            for (var i = segmentCount; i>=0; i--) {\r\n                this.getPoint(j, i, temp);\r\n                minX = Math.min(minX, temp.x);\r\n                maxX = Math.max(maxX, temp.x);\r\n                minY = Math.min(minY, temp.y);\r\n                maxY = Math.max(maxY, temp.y);\r\n            }\r\n        var bounds = this.bounds;\r\n        bounds.x = minX;\r\n        bounds.y = minY;\r\n        bounds.width = maxX - minX;\r\n        bounds.height = maxY - minY;\r\n    },\r\n    getBounds: function() {\r\n        if (!this.bounds) {\r\n            this.calcBounds();\r\n        }\r\n        return this.bounds;\r\n    },\r\n    intersectRect: function(rect) {\r\n        var segmentCount = this.segmentCount;\r\n        for (var j=3; j<5; j++)\r\n            for (var i = segmentCount; i>=0; i--) {\r\n                this.getPoint(j, i, temp);\r\n                if (rect.contains(temp.x, temp.y))\r\n                    return true;\r\n            }\r\n        return false;\r\n    },\r\n    liesInRect: function(rect) {\r\n        var segmentCount = this.segmentCount;\r\n        for (var j=3; j<5; j++)\r\n            for (var i = segmentCount; i>=0; i--) {\r\n                this.getPoint(j, i, temp);\r\n                if (!rect.contains(temp.x, temp.y))\r\n                    return false;\r\n            }\r\n        return true;\r\n    },\r\n    toJson: function() {\r\n        return [ this.id, this.centerPosition.x, this.centerPosition.y, this.startPosition.x, this.startPosition.y,\r\n            this.endPosition.x, this.endPosition.y, this.len, this.curve, this.segmentCount, this.startAngle, this.endAngle, this.pos,\r\n            this.highwayPos];\r\n    },\r\n    fromJson: function(json, path) {\r\n        this.init(path.rails);\r\n        this.path = path;\r\n        this.id = json[0];\r\n        this.centerPosition.x = json[1];\r\n        this.centerPosition.y = json[2];\r\n        this.startPosition.x = json[3];\r\n        this.startPosition.y = json[4];\r\n        this.endPosition.x = json[5];\r\n        this.endPosition.y = json[6];\r\n        this.len = json[7];\r\n        this.curve = json[8];\r\n        this.segmentCount = json[9];\r\n        this.startAngle = json[10];\r\n        this.endAngle = json[11];\r\n        this.pos = json[12];\r\n        this.highwayPos = json[13];\r\n        return this;\r\n    },\r\n    saveBin: function (buffer) {\r\n        buffer.writeInt(this.id);\r\n        buffer.writeFloat(this.startPosition.x);\r\n        buffer.writeFloat(this.startPosition.y);\r\n        buffer.writeInt(this.startAngle);\r\n        var delta = (this.endAngle - this.startAngle + this.rails.grad) % this.rails.grad;\r\n        if (this.curve<0) delta = delta - this.rails.grad;\r\n        buffer.writeInt(delta);\r\n        buffer.writeFloat(this.len);\r\n        buffer.writeFloat(this.pos);\r\n        buffer.writeFloat(this.highwayPos);\r\n    },\r\n    loadBin: function(buffer, path) {\r\n        var id = buffer.readInt();\r\n        this.startPosition.x = buffer.readFloat();\r\n        this.startPosition.y = buffer.readFloat();\r\n        var startAngle = buffer.readInt();\r\n        var delta = buffer.readInt();\r\n        var len = buffer.readFloat();\r\n        if (delta == 0) {\r\n            path.rails.createStraight(this.startPosition, startAngle, len, this);\r\n        } else {\r\n            path.rails.createCurve(this.startPosition, startAngle, delta, this);\r\n        }\r\n        this.path = path;\r\n        this.id = id;\r\n        this.pos = buffer.readFloat();\r\n        this.highwayPos = buffer.readFloat();\r\n        return this;\r\n    }\r\n};\r\n","/**\r\n * Created by Liza on 01.08.2015.\r\n */\r\n\r\nvar Point = require('./pixi/Point');\r\nvar Rectangle = require('./pixi/Rectangle');\r\n\r\nfunction Switch(rails) {\r\n    if (rails) this.init(rails);\r\n}\r\n\r\nmodule.exports = Switch;\r\n\r\nSwitch.prototype = {\r\n    id: 0,\r\n    pathTo: 0,\r\n    pathFrom: 0,\r\n    railTo: 0,\r\n    railFrom: 0,\r\n    posTo: 0,\r\n    posFrom: 0,\r\n    init: function(pathFrom, railFrom, posFrom, pathTo, railTo, posTo) {\r\n        var rails = pathFrom.rails;\r\n        this.id = ++rails.incrementId;\r\n        this.pathFrom = pathFrom || 0;\r\n        this.railFrom = railFrom || 0;\r\n        this.posFrom = posFrom || 0;\r\n        this.pathTo = pathTo || 0;\r\n        this.railTo = railTo || 0;\r\n        this.posTo = posTo || 0;\r\n        return this;\r\n    },\r\n    copy: function(sw) {\r\n        this.id = sw.id;\r\n        this.railTo = sw.railTo;\r\n        this.railFrom = sw.railFrom;\r\n        this.posTo = sw.posTo;\r\n        this.posFrom = sw.posFrom;\r\n        this.pathTo = sw.pathTo;\r\n        this.pathFrom = sw.pathFrom;\r\n        return this;\r\n    },\r\n    clone: function() {\r\n        var sw = new Switch();\r\n        sw.copy(this);\r\n        return sw;\r\n    },\r\n    toJson: function() {\r\n        return {\r\n            pathTo: this.pathTo.id,\r\n            railTo: this.railTo.id,\r\n            posTo: this.posTo,\r\n            pathFrom: this.pathFrom.id,\r\n            railFrom: this.railFrom.id,\r\n            posFrom: this.posFrom\r\n        }\r\n    },\r\n    saveBin: function(buffer) {\r\n        buffer.writeInt(this.pathTo.id);\r\n        buffer.writeInt(this.railTo.id);\r\n        buffer.writeFloat(this.posTo);\r\n        buffer.writeInt(this.pathFrom.id);\r\n        buffer.writeInt(this.railFrom.id);\r\n        buffer.writeFloat(this.posFrom);\r\n    },\r\n    loadBin: function(buffer) {\r\n        this.pathTo = buffer.readInt();\r\n        this.railTo = buffer.readInt();\r\n        this.posTo = buffer.readFloat();\r\n        this.pathFrom = buffer.readInt();\r\n        this.railFrom = buffer.readInt();\r\n        this.posFrom = buffer.readFloat();\r\n        return this;\r\n    }\r\n};\r\n","function Tracker(pos, rail) {\r\n    this.pos = pos;\r\n    this.travel = 0;\r\n    this.rail = rail;\r\n}\r\n\r\nmodule.exports = Tracker;\r\n\r\nTracker.prototype.getPos = function() {\r\n    return this.rail.pointAt(this.pos);\r\n}\r\n\r\nTracker.prototype.move = function(ds, rand) {\r\n    this.pos += ds;\r\n    cycle :while (this.pos >= this.rail.len && this.rail.next) {\r\n        var rail = this.rail;\r\n        this.travel += rail.len;\r\n        this.pos -= rail.len - rail.nextPos;\r\n\r\n        var path = rail.next.path;\r\n        for (var i = 0; i < path.waysOut.length; i++) {\r\n            var w = path.waysOut[i];\r\n            if (w.railFrom == rail && w.enabled) {\r\n                this.rail = w.railTo;\r\n                continue cycle;\r\n            }\r\n        }\r\n        this.rail = rail.next;\r\n    }\r\n}\r\n","/**\n * Created by Liza on 11.08.2015.\n */\n\nvar Point = require('./pixi/Point');\nfunction TrainWay(level, listener) {\n    this.level = level;\n    this.options = level.gameRes.options;\n    this.types = level.gameRes.obstacles;\n    this.segments = [];\n    this.obstacles = [];\n    this.curPos = 0;\n    this.obstPos = this.options.startCoord || 200;\n    this.listener = listener;\n}\n\nfunction patchIndex(level, rail) {\n    if (!rail) return -1;\n    for (var i=0;i<level.patches.length && i<4;i++) {\n        if (level.patches[i].paths.indexOf(rail.path)>=0) return i;\n    }\n    return -1;\n}\n\nmodule.exports = TrainWay;\n\nTrainWay.prototype = {\n    add: function(seg, nextPos) {\n        nextPos = nextPos || 0;\n        seg.coord = this.curPos - nextPos;\n        this.segments.push(seg);\n        this.curPos += seg.len - nextPos;\n    },\n    pop: function(seg) {\n        var s = this.segments.pop();\n        this.curPos -= s.len - this.tail().nextPos;\n    },\n    tail: function(index) {\n        return this.segments[this.segments.length-1-(index|0)];\n    },\n    shift: function() {\n        this.segments.shift();\n    },\n    update: function(dt, maxX) {\n        var level = this.level;\n        var segments = this.segments;\n        var obstacles = this.obstacles;\n        var listener = this.listener;\n        if (segments.length>0) {\n            while (patchIndex(level, segments[0])<0) {\n                this.shift();\n            }\n        } else {\n            this.add(level.patches[0].paths[0].segments[0]);\n        }\n        var oldIndex2 = segments.length;\n        while (patchIndex(level, this.tail())<0) {\n            this.pop();\n        }\n        var oldIndex = segments.length;\n        while (patchIndex(level, this.tail().next)>=0) {\n            this.add(this.tail().next, this.tail().nextPos);\n        }\n        while (obstacles.length>0 && obstacles[0].coord < segments[0].coord) {\n            listener && listener.onRemove(obstacles.shift());\n        }\n        if (oldIndex != oldIndex2 || oldIndex != segments.length)\n            this.expand(oldIndex);\n        for (var i=0;i<obstacles.length;i++) {\n            listener && listener.onUpdate(obstacles[i], dt, maxX);\n        }\n    },\n    tempPoint: new Point(),\n    camX: function(pos, w, w2) {\n        w  = w || 100;\n        w2 = w2 || w;\n        var segments = this.segments;\n        var x = -1, x0 = -1;\n        for (var i=0;i<segments.length;i++) {\n            var seg = segments[i];\n            if (pos>0) {\n                if (pos <= seg.coord + seg.len) {\n                    x = seg.pointAt(pos - seg.coord, this.tempPoint).x;\n                    x0 = x;\n                    pos = 0;\n                }\n            }\n            if (pos==0) {\n                if (seg.endPosition.x >= x + w) return Math.max(x, x0-w2);\n                x = Math.min(x, seg.endPosition.x);\n            }\n        }\n        return Math.max(x, x0-w2);\n    },\n    expand: function(oldIndex) {\n        var segments = this.segments;\n        var obstacles = this.obstacles;\n        var options = this.options;\n        var listener = this.listener;\n        var level = this.level;\n        if (options.obstacles != 1) return;\n\n        //1. find object obstacles//\n        var o = [];\n        for (var i=oldIndex; i<segments.length; i++) {\n            var s = segments[i];\n            if (s.mapObj) {\n                var mapObj = s.mapObj;\n                for (var t=0; t<this.types.length;t++) {\n                    var tt = this.types[t];\n                    if (tt.bindObj == mapObj.name) {\n                        var obst = Object.create(tt);\n                        obst.way = this;\n                        obst.coord = s.coord + (obst.railPos || 0);\n                        obst.position = 0;\n                        obst.mapObj = mapObj;\n                        obst.state = obst.state || 0;\n                        obst.special = true;\n                        obstacles.push(obst);\n                        o.push(obst);\n                    }\n                }\n            }\n\n            if (!s.next || s.next.path != s.path) {\n                //end of line\n                var ind = patchIndex(level, s);\n                var ind2 = s.next?patchIndex(level, s.next):-1;\n                if (ind!=ind2 && level.patches[ind].highway) {\n                    for (var t=0; t<this.types.length;t++) {\n                        var tt = this.types[t];\n                        if (tt.name.substring(0, 7) != \"highway\") continue;\n                        var obst = Object.create(tt);\n                        obst.way = this;\n                        obst.coord = s.coord + s.highwayPos;\n                        obst.position = 0;\n                        obst.mapObj = tt.name;\n                        obst.state = obst.state || 0;\n                        obst.special = true;\n                        obstacles.push(obst);\n                        o.push(obst);\n                    }\n                }\n            }\n        }\n        var roster = [];\n        cycle:while (this.obstPos < this.curPos + 1000) {\n            if (roster.length == 0) {\n                var sumProb = 0;\n                for (var i = 0; i < this.types.length; i++) {\n                    var tt = this.types[i];\n                    if (tt.hasOwnProperty(\"exactPlace\")) {\n                        if (tt.exactPlace < this.curPos + 1000 && tt.maxTimes>0) {\n                            tt.maxTimes --;\n                            var obst = Object.create(tt);\n                            obst.way = this;\n                            obst.coord = tt.exactPlace;\n                            obst.position = 0;\n                            obst.state = obst.state || 0;\n                            obst.special = true;\n                            obstacles.push(obst);\n                            o.push(obst);\n                        }\n                    } else\n                    if (tt.hasOwnProperty(\"prob\")) {\n                        if (tt.hasOwnProperty(\"maxTimes\")) {\n                            if (tt.maxTimes <= 0) continue;\n                        }\n                        if (tt.hasOwnProperty(\"minDist\")) {\n                            if (this.obstPos < tt.minDist) continue;\n                        }\n                        roster.push(tt);\n                        sumProb += tt.prob;\n                    }\n                }\n            }\n\n            var typeS = Math.random() * sumProb | 0;\n            var typeInd = 0;\n            while (typeInd + 1 < roster.length && roster[typeInd].prob <= typeS) {\n                typeS -= roster[typeInd].prob;\n                typeInd++;\n            }\n\n            var t = (options.betweenObstacles || 100) * (Math.random() + 1);\n            this.obstPos += t;\n\n            for (var i = 0; i < o.length; i++) {\n                if (Math.abs(o[i].coord - this.obstPos) < 100)\n                    continue cycle;\n            }\n\n            var obj = Object.create(roster[typeInd]);\n            obj.way = this;\n            obj.coord = this.obstPos;\n            obj.position = 0;\n            obj.state = obj.state || 0;\n            obstacles.push(obj);\n\n            if (roster[typeInd].hasOwnProperty(\"maxTimes\")) {\n                roster[typeInd].maxTimes--;\n                roster = [];\n            }\n        }\n\n        var coord = oldIndex < segments.length?segments[oldIndex].coord: this.curPos;\n        var remove = [];\n        cycle2: for (var i=0;i<obstacles.length;i++) {\n            var obst = obstacles[i];\n            if (!obst.special) {\n                for (var j = 0; j < o.length; j++) {\n                    if (Math.abs(o[j].coord - obst.coord) < 100) {\n                        remove.push(i);\n                        continue cycle2;\n                    }\n                }\n            }\n\n            if (obst.coord < coord) continue;\n            var j=0;\n            while (j<segments.length && segments[j].coord + segments[j].len <= obst.coord) {\n                j++;\n            }\n            if (j==segments.length) {\n                if (obst.mapObj) {\n                    remove.push(i);\n                }\n                continue;\n            }\n            var flag = !obst.position;\n            obst.position = segments[j].pointAt(obst.coord - segments[j].coord);\n            if (flag) {\n                listener && listener.onAdd(obst);\n            }\n            listener && listener.onChange(obst);\n        }\n        while (remove.length>0) {\n            var r = remove.pop();\n            listener && listener.onRemove(obstacles[r]);\n            obstacles.splice(r, 1);\n        }\n    }\n}\n","var Point = require('./pixi/Point');\r\n\r\nfunction WayTracker(way, pos) {\r\n    this.way = way;\r\n    this.pos = pos;\r\n    this.rail = way.segments[0];\r\n    this.position = new Point();\r\n    this.move(0);\r\n}\r\n\r\nmodule.exports = WayTracker;\r\n\r\nWayTracker.prototype = {\r\n    move: function(ds) {\r\n        this.pos += ds;\r\n        var segments = this.way.segments;\r\n        for (var i = 0; i < segments.length; i++) {\r\n            var seg = segments[i];\r\n            if (seg.coord + seg.len >= this.pos) {\r\n                this.rail = seg;\r\n                seg.pointAt(this.pos - seg.coord, this.position);\r\n                return this;\r\n            }\r\n        }\r\n        return this;\r\n    },\r\n    copy: function(src) {\r\n        this.pos = src.pos;\r\n        this.rail = src.rail;\r\n        return this;\r\n    }\r\n}\r\n\r\n","/**\r\n * Created by Liza on 02.08.2015.\r\n */\r\n\r\nmodule.exports = {\r\n    // These will be mixed to be made publicly available,\r\n    // while this module is used internally in core\r\n    // to avoid circular dependencies and cut down on\r\n    // internal module requires.\r\n\r\n    AABB: require('./AABB'),\r\n    Builder: require('./Builder'),\r\n    FieldObject: require('./FieldObject'),\r\n    Generator: require('./Generator'),\r\n    Buffer: require('./Buffer'),\r\n    Grid: require('./Grid'),\r\n    Level: require('./Level'),\r\n    Path: require('./Path'),\r\n    Rails: require('./Rails'),\r\n    Switch: require('./Switch'),\r\n    Tracker: require('./Tracker'),\r\n    TrainWay: require('./TrainWay'),\r\n    WayTracker: require('./WayTracker'),\r\n    GameResources: require('./GameResources'),\r\n    Point: require('./pixi/Point'),\r\n    Rectangle: require('./pixi/Rectangle'),\r\n    setOptionDefaults: function(options) {\r\n        options.width = options.width || 1200;\r\n        options.height = options.height || 720;\r\n        options.wayLen = options.wayLen || 150;\r\n        options.trainStartSpeed = options.trainStartSpeed || 100;\r\n        options.trainMaxSpeed = options.trainMaxSpeed || 100;\r\n        options.trainRandomWaySpeed = options.trainRandomWaySpeed || 100;\r\n        options.trainDistanceBeforeMaxSpeed = options.trainDistanceBeforeMaxSpeed || 10000;\r\n        options.trainTraction = options.trainTraction || 2;\r\n        options.showTipDistance = options.showTipDistance || 100;\r\n        options.startWays = options.startWays || 1;\r\n        options.minWays = options.minWays || 1;\r\n        options.maxWays = options.maxWays || 1;\r\n        options.lazyPatches = options.lazyPatches || 7;\r\n        options.smartCam = options.smartCam || 2;\r\n        options.frontCanvas = options.frontCanvas || 2;\r\n        options.backCanvas = options.backCanvas || 1;\r\n        options.webworker = options.webworker || 1;\r\n        options.railsSize = options.railsSize || 2;\r\n        options.topOffset = options.topOffset || 40;\r\n        options.bottomOffset = options.bottomOffset || 25;\r\n        options.webgl = options.webgl || 1;\r\n        options.obstacles = options.obstacles || 1;\r\n        options.randomWay = options.randomWay || 1;\r\n        options.endStation = options.endStation || 0.5;\r\n        options.endStationCoeff = options.endStationCoeff || 200;\r\n        return options;\r\n    }\r\n};\r\n","/**\r\n * The Point object represents a location in a two-dimensional coordinate system, where x represents\r\n * the horizontal axis and y represents the vertical axis.\r\n *\r\n * @class\r\n * @memberof PIXI\r\n * @param [x=0] {number} position of the point on the x axis\r\n * @param [y=0] {number} position of the point on the y axis\r\n */\r\nfunction Point(x, y)\r\n{\r\n    /**\r\n     * @member {number}\r\n     * @default 0\r\n     */\r\n    this.x = x || 0;\r\n\r\n    /**\r\n     * @member {number}\r\n     * @default 0\r\n     */\r\n    this.y = y || 0;\r\n}\r\n\r\nPoint.prototype.constructor = Point;\r\nmodule.exports = Point;\r\n\r\n/**\r\n * Creates a clone of this point\r\n *\r\n * @return {PIXI.Point} a copy of the point\r\n */\r\nPoint.prototype.clone = function ()\r\n{\r\n    return new Point(this.x, this.y);\r\n};\r\n\r\n/**\r\n * Copies x and y from the given point\r\n *\r\n * @param p {PIXI.Point}\r\n */\r\nPoint.prototype.copy = function (p) {\r\n    this.set(p.x, p.y);\r\n};\r\n\r\n/**\r\n * Returns true if the given point is equal to this point\r\n *\r\n * @param p {PIXI.Point}\r\n * @returns {boolean}\r\n */\r\nPoint.prototype.equals = function (p) {\r\n    return (p.x === this.x) && (p.y === this.y);\r\n};\r\n\r\n/**\r\n * Sets the point to a new x and y position.\r\n * If y is omitted, both x and y will be set to x.\r\n *\r\n * @param [x=0] {number} position of the point on the x axis\r\n * @param [y=0] {number} position of the point on the y axis\r\n */\r\nPoint.prototype.set = function (x, y)\r\n{\r\n    this.x = x || 0;\r\n    this.y = y || ( (y !== 0) ? this.x : 0 ) ;\r\n};\r\n","/**\r\n * the Rectangle object is an area defined by its position, as indicated by its top-left corner point (x, y) and by its width and its height.\r\n *\r\n * @class\r\n * @memberof PIXI\r\n * @param x {number} The X coordinate of the upper-left corner of the rectangle\r\n * @param y {number} The Y coordinate of the upper-left corner of the rectangle\r\n * @param width {number} The overall width of this rectangle\r\n * @param height {number} The overall height of this rectangle\r\n */\r\nfunction Rectangle(x, y, width, height)\r\n{\r\n    /**\r\n     * @member {number}\r\n     * @default 0\r\n     */\r\n    this.x = x || 0;\r\n\r\n    /**\r\n     * @member {number}\r\n     * @default 0\r\n     */\r\n    this.y = y || 0;\r\n\r\n    /**\r\n     * @member {number}\r\n     * @default 0\r\n     */\r\n    this.width = width || 0;\r\n\r\n    /**\r\n     * @member {number}\r\n     * @default 0\r\n     */\r\n    this.height = height || 0;\r\n\r\n    /**\r\n     * The type of the object, mainly used to avoid `instanceof` checks\r\n     *\r\n     * @member {number}\r\n     */\r\n    this.type = 1;\r\n}\r\n\r\nRectangle.prototype.constructor = Rectangle;\r\nmodule.exports = Rectangle;\r\n\r\n/**\r\n * A constant empty rectangle.\r\n *\r\n * @static\r\n * @constant\r\n */\r\nRectangle.EMPTY = new Rectangle(0, 0, 0, 0);\r\n\r\n\r\n/**\r\n * Creates a clone of this Rectangle\r\n *\r\n * @return {PIXI.Rectangle} a copy of the rectangle\r\n */\r\nRectangle.prototype.clone = function ()\r\n{\r\n    return new Rectangle(this.x, this.y, this.width, this.height);\r\n};\r\n\r\n/**\r\n * Checks whether the x and y coordinates given are contained within this Rectangle\r\n *\r\n * @param x {number} The X coordinate of the point to test\r\n * @param y {number} The Y coordinate of the point to test\r\n * @return {boolean} Whether the x/y coordinates are within this Rectangle\r\n */\r\nRectangle.prototype.contains = function (x, y)\r\n{\r\n    if (this.width <= 0 || this.height <= 0)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    if (x >= this.x && x < this.x + this.width)\r\n    {\r\n        if (y >= this.y && y < this.y + this.height)\r\n        {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n};\r\n"]}